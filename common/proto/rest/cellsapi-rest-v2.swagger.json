{
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "activityObject": {
      "properties": {
        "@context": {
          "type": "string"
        },
        "accuracy": {
          "format": "float",
          "title": "Place Properties",
          "type": "number"
        },
        "actor": {
          "$ref": "#/definitions/activityObject",
          "title": "Activity Properties"
        },
        "altitude": {
          "format": "float",
          "type": "number"
        },
        "anyOf": {
          "$ref": "#/definitions/activityObject"
        },
        "attachment": {
          "$ref": "#/definitions/activityObject"
        },
        "attributedTo": {
          "$ref": "#/definitions/activityObject"
        },
        "audience": {
          "$ref": "#/definitions/activityObject"
        },
        "bcc": {
          "$ref": "#/definitions/activityObject"
        },
        "bto": {
          "$ref": "#/definitions/activityObject"
        },
        "cc": {
          "$ref": "#/definitions/activityObject"
        },
        "closed": {
          "format": "date-time",
          "type": "string"
        },
        "content": {
          "$ref": "#/definitions/activityObject"
        },
        "context": {
          "$ref": "#/definitions/activityObject"
        },
        "current": {
          "$ref": "#/definitions/activityObject"
        },
        "deleted": {
          "format": "date-time",
          "type": "string"
        },
        "duration": {
          "format": "date-time",
          "type": "string"
        },
        "endTime": {
          "format": "date-time",
          "type": "string"
        },
        "first": {
          "$ref": "#/definitions/activityObject"
        },
        "formerType": {
          "$ref": "#/definitions/activityObjectType",
          "title": "Tombstone Properties"
        },
        "generator": {
          "$ref": "#/definitions/activityObject"
        },
        "height": {
          "format": "int32",
          "type": "integer"
        },
        "href": {
          "title": "Link Properties",
          "type": "string"
        },
        "hreflang": {
          "type": "string"
        },
        "icon": {
          "$ref": "#/definitions/activityObject"
        },
        "id": {
          "type": "string"
        },
        "image": {
          "$ref": "#/definitions/activityObject"
        },
        "inReplyTo": {
          "$ref": "#/definitions/activityObject"
        },
        "instrument": {
          "$ref": "#/definitions/activityObject"
        },
        "items": {
          "items": {
            "$ref": "#/definitions/activityObject",
            "type": "object"
          },
          "title": "Collection Properties",
          "type": "array"
        },
        "last": {
          "$ref": "#/definitions/activityObject"
        },
        "latitude": {
          "format": "float",
          "type": "number"
        },
        "location": {
          "$ref": "#/definitions/activityObject"
        },
        "longitude": {
          "format": "float",
          "type": "number"
        },
        "markdown": {
          "type": "string"
        },
        "mediaType": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "next": {
          "$ref": "#/definitions/activityObject"
        },
        "object": {
          "$ref": "#/definitions/activityObject"
        },
        "oneOf": {
          "$ref": "#/definitions/activityObject",
          "title": "Question Properties"
        },
        "origin": {
          "$ref": "#/definitions/activityObject"
        },
        "partOf": {
          "$ref": "#/definitions/activityObject"
        },
        "prev": {
          "$ref": "#/definitions/activityObject"
        },
        "preview": {
          "$ref": "#/definitions/activityObject"
        },
        "published": {
          "format": "date-time",
          "type": "string"
        },
        "radius": {
          "format": "float",
          "type": "number"
        },
        "rel": {
          "type": "string"
        },
        "relationship": {
          "$ref": "#/definitions/activityObject"
        },
        "replies": {
          "$ref": "#/definitions/activityObject"
        },
        "result": {
          "$ref": "#/definitions/activityObject"
        },
        "startTime": {
          "format": "date-time",
          "type": "string"
        },
        "subject": {
          "$ref": "#/definitions/activityObject",
          "title": "Relationship Properties"
        },
        "summary": {
          "type": "string"
        },
        "tag": {
          "$ref": "#/definitions/activityObject"
        },
        "target": {
          "$ref": "#/definitions/activityObject"
        },
        "to": {
          "$ref": "#/definitions/activityObject"
        },
        "totalItems": {
          "format": "int32",
          "type": "integer"
        },
        "type": {
          "$ref": "#/definitions/activityObjectType"
        },
        "units": {
          "type": "string"
        },
        "updated": {
          "format": "date-time",
          "type": "string"
        },
        "url": {
          "$ref": "#/definitions/activityObject"
        },
        "width": {
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "activityObjectType": {
      "default": "BaseObject",
      "enum": [
        "BaseObject",
        "Activity",
        "Link",
        "Mention",
        "Collection",
        "OrderedCollection",
        "CollectionPage",
        "OrderedCollectionPage",
        "Application",
        "Group",
        "Organization",
        "Person",
        "Service",
        "Article",
        "Audio",
        "Document",
        "Event",
        "Image",
        "Note",
        "Page",
        "Place",
        "Profile",
        "Relationship",
        "Tombstone",
        "Video",
        "Accept",
        "Add",
        "Announce",
        "Arrive",
        "Block",
        "Create",
        "Delete",
        "Dislike",
        "Flag",
        "Follow",
        "Ignore",
        "Invite",
        "Join",
        "Leave",
        "Like",
        "Listen",
        "Move",
        "Offer",
        "Question",
        "Reject",
        "Read",
        "Remove",
        "TentativeReject",
        "TentativeAccept",
        "Travel",
        "Undo",
        "Update",
        "UpdateComment",
        "UpdateMeta",
        "View",
        "Workspace",
        "Digest",
        "Folder",
        "Cell",
        "Share"
      ],
      "title": "- Collection: CollectionTypes\n - Application: Actor Types\n - Article: Objects Types\n - Accept: Activity Types\n - Workspace: Pydio Types",
      "type": "string"
    },
    "activityOwnerType": {
      "default": "NODE",
      "enum": [
        "NODE",
        "USER"
      ],
      "type": "string"
    },
    "activitySubscription": {
      "properties": {
        "Events": {
          "items": {
            "type": "string"
          },
          "title": "List of events to listen to",
          "type": "array"
        },
        "ObjectId": {
          "title": "If of the owner",
          "type": "string"
        },
        "ObjectType": {
          "$ref": "#/definitions/activityOwnerType",
          "title": "Type of owner"
        },
        "UserId": {
          "title": "Id of the user for this subscription",
          "type": "string"
        }
      },
      "type": "object"
    },
    "idmACL": {
      "description": "ACL are the basic flags that can be put anywhere in the tree to provide some specific rights to a given role.\nThe context of how they apply can be fine-tuned by workspace.",
      "properties": {
        "Action": {
          "$ref": "#/definitions/idmACLAction",
          "title": "Action on which this ACL provides control"
        },
        "ID": {
          "title": "Unique ID of this ACL",
          "type": "string"
        },
        "NodeID": {
          "title": "Associated Node",
          "type": "string"
        },
        "RoleID": {
          "title": "Associated Role",
          "type": "string"
        },
        "WorkspaceID": {
          "title": "Associated Workspace",
          "type": "string"
        }
      },
      "type": "object"
    },
    "idmACLAction": {
      "properties": {
        "Name": {
          "title": "ACL Action name, most frequent values are \"read\" or \"write\"",
          "type": "string"
        },
        "Value": {
          "title": "ACL Action value",
          "type": "string"
        }
      },
      "type": "object"
    },
    "idmRole": {
      "description": "Role represents a generic set of permissions that can be applied to any users or groups.",
      "properties": {
        "AutoApplies": {
          "items": {
            "type": "string"
          },
          "title": "List of profiles (standard, shared, admin) on which the role will be automatically applied",
          "type": "array"
        },
        "ForceOverride": {
          "description": "Is used in a stack of roles, this one will always be applied last.",
          "type": "boolean"
        },
        "GroupRole": {
          "title": "Whether this role is attached to a Group object",
          "type": "boolean"
        },
        "IsTeam": {
          "title": "Whether this role represents a user team or not",
          "type": "boolean"
        },
        "Label": {
          "title": "Label of this role",
          "type": "string"
        },
        "LastUpdated": {
          "format": "int32",
          "title": "Last modification date of the role",
          "type": "integer"
        },
        "Policies": {
          "items": {
            "$ref": "#/definitions/serviceResourcePolicy",
            "type": "object"
          },
          "title": "List of policies for securing this role access",
          "type": "array"
        },
        "PoliciesContextEditable": {
          "title": "Whether the policies resolve into an editable state",
          "type": "boolean"
        },
        "UserRole": {
          "title": "Whether this role is attached to a User object",
          "type": "boolean"
        },
        "Uuid": {
          "title": "Unique identifier of this role",
          "type": "string"
        }
      },
      "type": "object"
    },
    "idmUser": {
      "properties": {
        "Attributes": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "A free list of attributes",
          "type": "object"
        },
        "GroupLabel": {
          "title": "Label of the group, field is empty for users",
          "type": "string"
        },
        "GroupPath": {
          "title": "Path to the parent group",
          "type": "string"
        },
        "IsGroup": {
          "title": "Whether this object is a group or a user",
          "type": "boolean"
        },
        "LastConnected": {
          "format": "int32",
          "title": "Last successful connection timestamp",
          "type": "integer"
        },
        "Login": {
          "title": "User login is used to connect, field is empty for groups",
          "type": "string"
        },
        "OldPassword": {
          "title": "OldPassword must be set when a user updates her own password",
          "type": "string"
        },
        "Password": {
          "title": "Password can be passed to be updated (but never read back), field is empty for groups",
          "type": "string"
        },
        "Policies": {
          "items": {
            "$ref": "#/definitions/serviceResourcePolicy",
            "type": "object"
          },
          "title": "Policies securing access to this user",
          "type": "array"
        },
        "PoliciesContextEditable": {
          "description": "Context-resolved to quickly check if user is editable or not.",
          "type": "boolean"
        },
        "Roles": {
          "items": {
            "$ref": "#/definitions/idmRole",
            "type": "object"
          },
          "title": "List of roles applied to this user or group",
          "type": "array"
        },
        "Uuid": {
          "title": "User unique identifier",
          "type": "string"
        }
      },
      "title": "User can represent either a User or a Group",
      "type": "object"
    },
    "idmWorkspace": {
      "description": "A Workspace is composed of a set of nodes UUIDs and is used to provide accesses to the tree via ACLs.",
      "properties": {
        "Attributes": {
          "title": "JSON-encoded list of attributes",
          "type": "string"
        },
        "Description": {
          "title": "Description of the workspace (max length 1000)",
          "type": "string"
        },
        "Label": {
          "title": "Label of the workspace (max length 500)",
          "type": "string"
        },
        "LastUpdated": {
          "format": "int32",
          "title": "Last modification time",
          "type": "integer"
        },
        "Policies": {
          "items": {
            "$ref": "#/definitions/serviceResourcePolicy",
            "type": "object"
          },
          "title": "Policies for securing access",
          "type": "array"
        },
        "PoliciesContextEditable": {
          "title": "Context-resolved to quickly check if workspace is editable or not",
          "type": "boolean"
        },
        "RootNodes": {
          "additionalProperties": {
            "$ref": "#/definitions/treeNode"
          },
          "title": "List of the Root Nodes in the tree that compose this workspace",
          "type": "object"
        },
        "RootUUIDs": {
          "items": {
            "type": "string"
          },
          "title": "Quick list of the RootNodes uuids",
          "type": "array"
        },
        "Scope": {
          "$ref": "#/definitions/idmWorkspaceScope",
          "title": "Scope can be ADMIN, ROOM (=CELL) or LINK"
        },
        "Slug": {
          "title": "Slug is an url-compatible form of the workspace label, or can be freely modified (max length 500)",
          "type": "string"
        },
        "UUID": {
          "title": "Unique identifier of the workspace",
          "type": "string"
        }
      },
      "type": "object"
    },
    "idmWorkspaceScope": {
      "default": "ANY",
      "enum": [
        "ANY",
        "ADMIN",
        "ROOM",
        "LINK"
      ],
      "type": "string"
    },
    "jobsAction": {
      "properties": {
        "ActionOutputFilter": {
          "$ref": "#/definitions/jobsActionOutputFilter",
          "title": "Previous action output filter"
        },
        "BreakAfter": {
          "title": "Stop full chain now : do not carry on executing next actions",
          "type": "boolean"
        },
        "Bypass": {
          "title": "Bypass this action (forward input to output and do nothing)",
          "type": "boolean"
        },
        "ChainedActions": {
          "items": {
            "$ref": "#/definitions/jobsAction",
            "type": "object"
          },
          "title": "Other actions to perform after this one is finished,\nusing the Output of this action as Input for the next.\nIf there are many, it is considered they can be triggered\nin parallel",
          "type": "array"
        },
        "ContextMetaFilter": {
          "$ref": "#/definitions/jobsContextMetaFilter",
          "title": "Metadata policy-based filter"
        },
        "DataFilter": {
          "$ref": "#/definitions/jobsDataSelector",
          "title": "Filter values from JsonBody"
        },
        "DataSelector": {
          "$ref": "#/definitions/jobsDataSelector",
          "title": "Collect/select values from JsonBody"
        },
        "DataSourceFilter": {
          "$ref": "#/definitions/jobsDataSourceSelector",
          "title": "DataSource objects filter"
        },
        "DataSourceSelector": {
          "$ref": "#/definitions/jobsDataSourceSelector",
          "title": "DataSource objects collector"
        },
        "Description": {
          "title": "User-defined comment for this action",
          "type": "string"
        },
        "FailedFilterActions": {
          "items": {
            "$ref": "#/definitions/jobsAction",
            "type": "object"
          },
          "title": "If any Filter is used, next actions can be triggered on Failure\nThis adds ability to create conditional Yes/No branches",
          "type": "array"
        },
        "ID": {
          "title": "String Identifier for specific action",
          "type": "string"
        },
        "IdmFilter": {
          "$ref": "#/definitions/jobsIdmSelector",
          "title": "Idm objects filter"
        },
        "IdmSelector": {
          "$ref": "#/definitions/jobsIdmSelector",
          "title": "Idm objects collector"
        },
        "Label": {
          "title": "User-defined label for this action",
          "type": "string"
        },
        "MergeAction": {
          "$ref": "#/definitions/jobsAction",
          "title": "CollectAction adds starts another chain after the whole ChainedAction/FailedFilterActions have been performed"
        },
        "NodesFilter": {
          "$ref": "#/definitions/jobsNodesSelector",
          "title": "Node Filter"
        },
        "NodesSelector": {
          "$ref": "#/definitions/jobsNodesSelector",
          "title": "Nodes Selector"
        },
        "Parameters": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "Defined parameters for this action",
          "type": "object"
        },
        "Timeout": {
          "title": "Optional timeout for this action",
          "type": "string"
        },
        "TriggerFilter": {
          "$ref": "#/definitions/jobsTriggerFilter",
          "title": "Filter on specific triggers"
        },
        "UsersFilter": {
          "$ref": "#/definitions/jobsUsersSelector",
          "title": "User Filter (deprecated in favor of IdmSelector)"
        },
        "UsersSelector": {
          "$ref": "#/definitions/jobsUsersSelector",
          "title": "Users Selector (deprecated in favor of IdmSelector)"
        }
      },
      "type": "object"
    },
    "jobsActionLog": {
      "properties": {
        "Action": {
          "$ref": "#/definitions/jobsAction"
        },
        "InputMessage": {
          "$ref": "#/definitions/jobsActionMessage"
        },
        "OutputMessage": {
          "$ref": "#/definitions/jobsActionMessage"
        }
      },
      "type": "object"
    },
    "jobsActionMessage": {
      "properties": {
        "Acls": {
          "items": {
            "$ref": "#/definitions/idmACL",
            "type": "object"
          },
          "title": "One or more ACL",
          "type": "array"
        },
        "Activities": {
          "items": {
            "$ref": "#/definitions/activityObject",
            "type": "object"
          },
          "title": "One or more Activity",
          "type": "array"
        },
        "DataSources": {
          "items": {
            "$ref": "#/definitions/objectDataSource",
            "type": "object"
          },
          "title": "One or more DataSource",
          "type": "array"
        },
        "Event": {
          "$ref": "#/definitions/protobufAny",
          "title": "Initial event that triggered the Job"
        },
        "Nodes": {
          "items": {
            "$ref": "#/definitions/treeNode",
            "type": "object"
          },
          "title": "One or more Node",
          "type": "array"
        },
        "OutputChain": {
          "items": {
            "$ref": "#/definitions/jobsActionOutput",
            "type": "object"
          },
          "title": "Stack of ActionOutput messages appended by all previous actions",
          "type": "array"
        },
        "Roles": {
          "items": {
            "$ref": "#/definitions/idmRole",
            "type": "object"
          },
          "title": "One or more Role",
          "type": "array"
        },
        "Users": {
          "items": {
            "$ref": "#/definitions/idmUser",
            "type": "object"
          },
          "title": "One or more User",
          "type": "array"
        },
        "Workspaces": {
          "items": {
            "$ref": "#/definitions/idmWorkspace",
            "type": "object"
          },
          "title": "One or more Workspace",
          "type": "array"
        }
      },
      "title": "Message passed along from one action to another, main properties\nare modified by the various actions.\nOutputChain is being stacked up when passing through actions",
      "type": "object"
    },
    "jobsActionOutput": {
      "properties": {
        "ErrorString": {
          "title": "Error",
          "type": "string"
        },
        "Ignored": {
          "title": "If action was returned WithIgnore()",
          "type": "boolean"
        },
        "JsonBody": {
          "format": "byte",
          "title": "Arbitrary JSON-encoded bytes",
          "type": "string"
        },
        "RawBody": {
          "format": "byte",
          "title": "Arbitrary bytes sequence",
          "type": "string"
        },
        "StringBody": {
          "title": "Arbitrary string",
          "type": "string"
        },
        "Success": {
          "title": "True if action succeeded",
          "type": "boolean"
        },
        "Time": {
          "format": "int32",
          "title": "Time taken to run the action",
          "type": "integer"
        },
        "Vars": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Vars container, values are json-encoded.",
          "type": "object"
        }
      },
      "title": "Standard output of an action. Success value is required\nother are optional",
      "type": "object"
    },
    "jobsActionOutputFilter": {
      "properties": {
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Query built from ActionOutputSingleQuery"
        }
      },
      "title": "ActionOutputFilter can be used to filter last message output",
      "type": "object"
    },
    "jobsCommand": {
      "default": "None",
      "enum": [
        "None",
        "Pause",
        "Resume",
        "Stop",
        "Delete",
        "RunOnce",
        "Inactive",
        "Active"
      ],
      "type": "string"
    },
    "jobsContextMetaFilter": {
      "properties": {
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Can be built with ContextMetaSingleQuery"
        },
        "Type": {
          "$ref": "#/definitions/jobsContextMetaFilterType",
          "title": "Type of context filter"
        }
      },
      "title": "PolicyContextFilter can be used to filter request metadata",
      "type": "object"
    },
    "jobsContextMetaFilterType": {
      "default": "RequestMeta",
      "enum": [
        "RequestMeta",
        "ContextUser"
      ],
      "type": "string"
    },
    "jobsCtrlCommand": {
      "properties": {
        "Cmd": {
          "$ref": "#/definitions/jobsCommand",
          "title": "Type of command to send (None, Pause, Resume, Stop, Delete, RunOnce, Inactive, Active)"
        },
        "JobId": {
          "title": "Id of the job",
          "type": "string"
        },
        "OwnerId": {
          "title": "Owner of the job",
          "type": "string"
        },
        "RunParameters": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "Parameters used for RunOnce command",
          "type": "object"
        },
        "TaskId": {
          "title": "Id of the associated task",
          "type": "string"
        }
      },
      "title": "Command sent to control a job or a task",
      "type": "object"
    },
    "jobsDataSelector": {
      "properties": {
        "ClearInput": {
          "title": "Clear previous selection",
          "type": "boolean"
        },
        "Collect": {
          "title": "Collect results",
          "type": "boolean"
        },
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "FanOutInput": {
          "title": "Ignore query and just fan out input.LastOutput.JsonBody",
          "type": "boolean"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Query used to compute output object or list of objects"
        },
        "Timeout": {
          "title": "Optional Timeout for this selector",
          "type": "string"
        }
      },
      "type": "object"
    },
    "jobsDataSourceSelector": {
      "properties": {
        "All": {
          "title": "Select all",
          "type": "boolean"
        },
        "ClearInput": {
          "title": "Clear previous selection",
          "type": "boolean"
        },
        "Collect": {
          "title": "Collect results",
          "type": "boolean"
        },
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "FanOutInput": {
          "title": "Ignore query and just fan out input.DataSources",
          "type": "boolean"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Composition of DataSourceSingleQueries"
        },
        "Timeout": {
          "title": "Optional Timeout for this selector",
          "type": "string"
        },
        "Type": {
          "$ref": "#/definitions/jobsDataSourceSelectorType",
          "title": "Selector type, either DataSource or Object service"
        }
      },
      "title": "Selector/Filter for DataSource objects",
      "type": "object"
    },
    "jobsDataSourceSelectorType": {
      "default": "DataSource",
      "enum": [
        "DataSource",
        "Object"
      ],
      "type": "string"
    },
    "jobsIdmSelector": {
      "properties": {
        "All": {
          "title": "Load all objects",
          "type": "boolean"
        },
        "ClearInput": {
          "title": "Clear previous selection",
          "type": "boolean"
        },
        "Collect": {
          "title": "Pass a slice of objects to one action, or trigger all actions in parallel",
          "type": "boolean"
        },
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "FanOutInput": {
          "title": "Ignore query and just fan out input.[Type]",
          "type": "boolean"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Serialized search query"
        },
        "Range": {
          "$ref": "#/definitions/jobsSelectorRange",
          "title": "Handle ranges"
        },
        "Timeout": {
          "title": "Optional Timeout for this selector",
          "type": "string"
        },
        "Type": {
          "$ref": "#/definitions/jobsIdmSelectorType",
          "title": "Type of objects to look for"
        }
      },
      "title": "Generic container for select/filter idm objects",
      "type": "object"
    },
    "jobsIdmSelectorType": {
      "default": "User",
      "enum": [
        "User",
        "Role",
        "Workspace",
        "Acl"
      ],
      "title": "Possible values for IdmSelector.Type",
      "type": "string"
    },
    "jobsJob": {
      "properties": {
        "Actions": {
          "items": {
            "$ref": "#/definitions/jobsAction",
            "type": "object"
          },
          "title": "Chain of actions to perform",
          "type": "array"
        },
        "AutoClean": {
          "title": "Remove job automatically once it is finished (success only)",
          "type": "boolean"
        },
        "AutoRestart": {
          "title": "Start task as soon as server is started",
          "type": "boolean"
        },
        "AutoStart": {
          "title": "Start task as soon as job is inserted",
          "type": "boolean"
        },
        "ContextMetaFilter": {
          "$ref": "#/definitions/jobsContextMetaFilter",
          "title": "Event Context Filter"
        },
        "CreatedAt": {
          "format": "int32",
          "title": "Timestamp for creation time",
          "type": "integer"
        },
        "Custom": {
          "title": "Job created by application or by administrator",
          "type": "boolean"
        },
        "DataSourceFilter": {
          "$ref": "#/definitions/jobsDataSourceSelector",
          "title": "DataSource objects filter"
        },
        "EventNames": {
          "items": {
            "type": "string"
          },
          "title": "How the job will be triggered.\nOne of these must be set (not exclusive)\nListen to a given set of events",
          "type": "array"
        },
        "Hooks": {
          "items": {
            "$ref": "#/definitions/jobsJobHook",
            "type": "object"
          },
          "title": "Expose this job through one or more-userspace APIs",
          "type": "array"
        },
        "ID": {
          "title": "Unique ID for this Job",
          "type": "string"
        },
        "IdmFilter": {
          "$ref": "#/definitions/jobsIdmSelector",
          "title": "Idm objects filter"
        },
        "Inactive": {
          "title": "Admin can temporarily disable this job",
          "type": "boolean"
        },
        "Label": {
          "title": "Human-readable Label",
          "type": "string"
        },
        "Languages": {
          "items": {
            "type": "string"
          },
          "title": "Optional list of languages detected in the context at launch time",
          "type": "array"
        },
        "MaxConcurrency": {
          "format": "int32",
          "title": "Task properties",
          "type": "integer"
        },
        "MergeAction": {
          "$ref": "#/definitions/jobsAction",
          "title": "Collect chain of actions into a merged output"
        },
        "Metadata": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional user-defined metadata, can be used for icon, documentation, pre-requisites, etc.",
          "type": "object"
        },
        "ModifiedAt": {
          "format": "int32",
          "title": "Timestamp for modification time",
          "type": "integer"
        },
        "NodeEventFilter": {
          "$ref": "#/definitions/jobsNodesSelector",
          "title": "Filter out specific events"
        },
        "Owner": {
          "title": "Who created this Job",
          "type": "string"
        },
        "Parameters": {
          "items": {
            "$ref": "#/definitions/jobsJobParameter",
            "type": "object"
          },
          "title": "Job-level parameters that can be passed to underlying actions",
          "type": "array"
        },
        "ResourcesDependencies": {
          "items": {
            "$ref": "#/definitions/protobufAny",
            "type": "object"
          },
          "title": "Additional dependencies that may be required when running the job",
          "type": "array"
        },
        "Schedule": {
          "$ref": "#/definitions/jobsSchedule",
          "title": "Schedule a periodic repetition"
        },
        "Tasks": {
          "items": {
            "$ref": "#/definitions/jobsTask",
            "type": "object"
          },
          "title": "Filled with currently running tasks",
          "type": "array"
        },
        "TasksSilentUpdate": {
          "title": "Do not send notification on task update",
          "type": "boolean"
        },
        "Timeout": {
          "title": "Optional Timeout any running job",
          "type": "string"
        },
        "UserEventFilter": {
          "$ref": "#/definitions/jobsUsersSelector",
          "title": "Deprecated in favor of more generic IdmSelector"
        },
        "VersionMeta": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "Additional Versioning Metadata",
          "type": "object"
        }
      },
      "type": "object"
    },
    "jobsJobHook": {
      "properties": {
        "AllowOverridePresets": {
          "title": "Allow trigger parameters to override default presets",
          "type": "boolean"
        },
        "ApiSlug": {
          "title": "Custom ApiSlug, otherwise use the job UUID",
          "type": "string"
        },
        "Metadata": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "Additional arbitrary metadata attached to this hook",
          "type": "object"
        },
        "Policies": {
          "items": {
            "$ref": "#/definitions/serviceResourcePolicy",
            "type": "object"
          },
          "title": "Set permissions for accessing this endpoint",
          "type": "array"
        },
        "PresetParameters": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "Preset parameters values when calling this endpoint. May be overriden by a map[string]string in the body",
          "type": "object"
        }
      },
      "title": "Dynamically expose a job trigger via API",
      "type": "object"
    },
    "jobsJobParameter": {
      "properties": {
        "Description": {
          "title": "Additional description",
          "type": "string"
        },
        "JsonChoices": {
          "title": "Additional data used by GUI elements",
          "type": "string"
        },
        "Mandatory": {
          "title": "If mandatory, job cannot start without a value",
          "type": "boolean"
        },
        "Name": {
          "title": "Parameter name",
          "type": "string"
        },
        "Type": {
          "title": "Parameter type used in GUI forms",
          "type": "string"
        },
        "Value": {
          "title": "Value saved for this parameter",
          "type": "string"
        }
      },
      "type": "object"
    },
    "jobsNodesSelector": {
      "properties": {
        "All": {
          "title": "Select all files - ignore any other condition",
          "type": "boolean"
        },
        "ClearInput": {
          "title": "Clear previous selection",
          "type": "boolean"
        },
        "Collect": {
          "title": "Whether to trigger one action per node or one action\nwith all nodes as selection",
          "type": "boolean"
        },
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "FanOutInput": {
          "title": "Ignore query and just fan out input.Nodes",
          "type": "boolean"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Pathes": {
          "items": {
            "type": "string"
          },
          "title": "Preset list of node pathes",
          "type": "array"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Query to apply to select users (or filter a given node passed by event)"
        },
        "Range": {
          "$ref": "#/definitions/jobsSelectorRange",
          "title": "Handle ranges"
        },
        "Timeout": {
          "title": "Optional Timeout for this selector",
          "type": "string"
        }
      },
      "title": "/////////////////\nJOB  SERVICE  //\n/////////////////",
      "type": "object"
    },
    "jobsSchedule": {
      "properties": {
        "Iso8601MinDelta": {
          "title": "Minimum time between two runs",
          "type": "string"
        },
        "Iso8601Schedule": {
          "description": "ISO 8601 Description of the scheduling for instance \"R2/2015-06-04T19:25:16.828696-07:00/PT4S\"\nwhere first part is the number of repetitions (if 0, infinite repetition), \nsecond part the starting date and last part, the duration between 2 occurrences.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "jobsSelectorRange": {
      "properties": {
        "Limit": {
          "title": "Limit number of results - use string to allow templating",
          "type": "string"
        },
        "Offset": {
          "title": "Start offset - use string to allow templating",
          "type": "string"
        },
        "OrderBy": {
          "title": "OrderBy a given field of the object",
          "type": "string"
        },
        "OrderDir": {
          "title": "Order direction (asc/desc)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "jobsTask": {
      "properties": {
        "ActionsLogs": {
          "items": {
            "$ref": "#/definitions/jobsActionLog",
            "type": "object"
          },
          "title": "Logs of all the actions performed",
          "type": "array"
        },
        "CanPause": {
          "title": "Can be paused/resumed",
          "type": "boolean"
        },
        "CanStop": {
          "title": "Can be interrupted",
          "type": "boolean"
        },
        "EndTime": {
          "format": "int32",
          "type": "integer"
        },
        "HasProgress": {
          "title": "Tasks publish a progress",
          "type": "boolean"
        },
        "ID": {
          "type": "string"
        },
        "JobID": {
          "type": "string"
        },
        "Progress": {
          "format": "float",
          "title": "Float value of the progress between 0 and 1",
          "type": "number"
        },
        "StartTime": {
          "format": "int32",
          "type": "integer"
        },
        "Status": {
          "$ref": "#/definitions/jobsTaskStatus"
        },
        "StatusMessage": {
          "type": "string"
        },
        "TriggerOwner": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "jobsTaskStatus": {
      "default": "Unknown",
      "enum": [
        "Unknown",
        "Idle",
        "Running",
        "Finished",
        "Interrupted",
        "Paused",
        "Any",
        "Error",
        "Queued"
      ],
      "title": "/////////////////\nTASK SERVICE  //\n/////////////////",
      "type": "string"
    },
    "jobsTriggerFilter": {
      "properties": {
        "Description": {
          "title": "Filter additional description",
          "type": "string"
        },
        "Label": {
          "title": "Filter custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Filter type"
        }
      },
      "title": "Filter for events, can be applied on action branches",
      "type": "object"
    },
    "jobsUsersSelector": {
      "properties": {
        "All": {
          "title": "Select all users",
          "type": "boolean"
        },
        "ClearInput": {
          "title": "Clear previous selection",
          "type": "boolean"
        },
        "Collect": {
          "title": "Wether to trigger one action per user or one action\nwith all user as a selection",
          "type": "boolean"
        },
        "Description": {
          "title": "Selector additional description",
          "type": "string"
        },
        "Label": {
          "title": "Selector custom label",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/serviceQuery",
          "title": "Filter users using this query"
        },
        "Timeout": {
          "title": "Optional Timeout for this selector",
          "type": "string"
        },
        "Users": {
          "items": {
            "$ref": "#/definitions/idmUser",
            "type": "object"
          },
          "title": "Preset set of Users",
          "type": "array"
        }
      },
      "title": "Select or filter users - should be replaced by more generic IdmSelector",
      "type": "object"
    },
    "objectDataSource": {
      "properties": {
        "ApiKey": {
          "title": "Corresponding objects service api key",
          "type": "string"
        },
        "ApiSecret": {
          "title": "Corresponding objects service api secret",
          "type": "string"
        },
        "CreationDate": {
          "format": "int32",
          "title": "Data Source creation date",
          "type": "integer"
        },
        "Disabled": {
          "title": "Whether this data source is disabled or running",
          "type": "boolean"
        },
        "EncryptionKey": {
          "title": "Encryption key used for encrypting data",
          "type": "string"
        },
        "EncryptionMode": {
          "$ref": "#/definitions/objectEncryptionMode",
          "title": "Type of encryption applied before sending data to storage"
        },
        "FlatStorage": {
          "title": "Store data in flat format (object-storage like)",
          "type": "boolean"
        },
        "LastSynchronizationDate": {
          "format": "int32",
          "title": "Data Source last synchronization date",
          "type": "integer"
        },
        "Name": {
          "title": "Name of the data source (max length 34)",
          "type": "string"
        },
        "ObjectsBaseFolder": {
          "title": "Corresponding objects service base folder inside the bucket",
          "type": "string"
        },
        "ObjectsBucket": {
          "title": "Corresponding objects service bucket",
          "type": "string"
        },
        "ObjectsHost": {
          "title": "Corresponding objects service host",
          "type": "string"
        },
        "ObjectsPort": {
          "format": "int32",
          "title": "Corresponding objects service port",
          "type": "integer"
        },
        "ObjectsSecure": {
          "title": "Corresponding objects service connection type",
          "type": "boolean"
        },
        "ObjectsServiceName": {
          "title": "Corresponding objects service name (underlying s3 service)",
          "type": "string"
        },
        "PeerAddress": {
          "title": "Peer address of the data source",
          "type": "string"
        },
        "SkipSyncOnRestart": {
          "title": "Do not trigger resync at start",
          "type": "boolean"
        },
        "StorageConfiguration": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "List of key values describing storage configuration",
          "type": "object"
        },
        "StorageType": {
          "$ref": "#/definitions/objectStorageType",
          "title": "Type of underlying storage (LOCAL, S3, AZURE, GCS)"
        },
        "VersioningPolicyName": {
          "title": "Versioning policy describes how files are kept in the versioning queue",
          "type": "string"
        },
        "Watch": {
          "title": "Not implemented, whether to watch for underlying changes on the FS",
          "type": "boolean"
        }
      },
      "title": "DataSource Object description",
      "type": "object"
    },
    "objectEncryptionMode": {
      "default": "CLEAR",
      "enum": [
        "CLEAR",
        "MASTER",
        "USER",
        "USER_PWD"
      ],
      "title": "Type of Encryption",
      "type": "string"
    },
    "objectStorageType": {
      "default": "LOCAL",
      "enum": [
        "LOCAL",
        "S3",
        "SMB",
        "CELLS",
        "AZURE",
        "GCS",
        "B2",
        "MANTA",
        "SIA"
      ],
      "title": "Type of Gateway",
      "type": "string"
    },
    "protobufAny": {
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
      "properties": {
        "@type": {
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "restActionParameters": {
      "properties": {
        "Await": {
          "type": "boolean"
        },
        "JsonParameters": {
          "type": "string"
        },
        "Nodes": {
          "items": {
            "$ref": "#/definitions/restNodeLocator",
            "type": "object"
          },
          "type": "array"
        },
        "SelectionUuid": {
          "type": "string"
        },
        "TargetNode": {
          "$ref": "#/definitions/restNodeLocator"
        }
      },
      "type": "object"
    },
    "restActionResponse": {
      "properties": {
        "AffectedNodes": {
          "items": {
            "$ref": "#/definitions/restNode",
            "type": "object"
          },
          "type": "array"
        },
        "Jobs": {
          "items": {
            "$ref": "#/definitions/jobsJob",
            "type": "object"
          },
          "type": "array"
        },
        "Status": {
          "$ref": "#/definitions/restActionStatus"
        }
      },
      "type": "object"
    },
    "restActionStatus": {
      "default": "Performed",
      "enum": [
        "Performed",
        "Background"
      ],
      "type": "string"
    },
    "restContextWorkspace": {
      "properties": {
        "Description": {
          "type": "string"
        },
        "IsRoot": {
          "type": "boolean"
        },
        "IsVirtualRoot": {
          "type": "boolean"
        },
        "Label": {
          "type": "string"
        },
        "Permissions": {
          "type": "string"
        },
        "Quota": {
          "format": "int64",
          "type": "string"
        },
        "QuotaUsage": {
          "format": "int64",
          "type": "string"
        },
        "Scope": {
          "$ref": "#/definitions/idmWorkspaceScope"
        },
        "SkipRecycle": {
          "type": "boolean"
        },
        "Slug": {
          "type": "string"
        },
        "Syncable": {
          "type": "boolean"
        },
        "Uuid": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restCountMeta": {
      "properties": {
        "Namespace": {
          "type": "string"
        },
        "Value": {
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "restCreateRequest": {
      "properties": {
        "Inputs": {
          "items": {
            "$ref": "#/definitions/restIncomingNode",
            "type": "object"
          },
          "type": "array"
        },
        "Recursive": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "restDataSourceFeatures": {
      "properties": {
        "Encrypted": {
          "type": "boolean"
        },
        "Versioned": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "restError": {
      "properties": {
        "Code": {
          "title": "Unique ID of the error",
          "type": "string"
        },
        "Detail": {
          "title": "Human-readable, longer description",
          "type": "string"
        },
        "Meta": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "Additional Metadata",
          "type": "object"
        },
        "Source": {
          "title": "Cells service name or other quickly useful info",
          "type": "string"
        },
        "Title": {
          "title": "Human-readable, short label",
          "type": "string"
        }
      },
      "title": "Generic error message",
      "type": "object"
    },
    "restFilePreview": {
      "properties": {
        "ContentType": {
          "type": "string"
        },
        "Dimension": {
          "format": "int32",
          "type": "integer"
        },
        "Processing": {
          "type": "boolean"
        },
        "URL": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restImageMeta": {
      "properties": {
        "Height": {
          "format": "int32",
          "type": "integer"
        },
        "JsonEXIF": {
          "type": "string"
        },
        "Orientation": {
          "format": "int32",
          "type": "integer"
        },
        "Width": {
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "restIncomingNode": {
      "properties": {
        "ContentType": {
          "type": "string"
        },
        "Locator": {
          "$ref": "#/definitions/restNodeLocator"
        },
        "TemplateUuid": {
          "type": "string"
        },
        "Type": {
          "$ref": "#/definitions/treeNodeType"
        }
      },
      "type": "object"
    },
    "restJsonMeta": {
      "properties": {
        "Namespace": {
          "type": "string"
        },
        "Value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restListTemplatesResponse": {
      "properties": {
        "Templates": {
          "items": {
            "$ref": "#/definitions/restTemplate",
            "type": "object"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "restLockInfo": {
      "properties": {
        "IsLocked": {
          "type": "boolean"
        },
        "Owner": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restLookupRequest": {
      "properties": {
        "Limit": {
          "format": "int64",
          "type": "string"
        },
        "Locators": {
          "items": {
            "$ref": "#/definitions/restNodeLocator",
            "type": "object"
          },
          "type": "array"
        },
        "Offset": {
          "format": "int64",
          "type": "string"
        },
        "Query": {
          "$ref": "#/definitions/treeQuery"
        },
        "SortDirDesc": {
          "type": "boolean"
        },
        "SortField": {
          "type": "string"
        },
        "StatFlags": {
          "items": {
            "format": "int64",
            "type": "integer"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "restMode": {
      "default": "Default",
      "enum": [
        "Default",
        "NodeReadOnly",
        "NodeWriteOnly",
        "LevelReadOnly"
      ],
      "type": "string"
    },
    "restNode": {
      "properties": {
        "Activities": {
          "items": {
            "$ref": "#/definitions/activityObject",
            "type": "object"
          },
          "type": "array"
        },
        "ContentLock": {
          "$ref": "#/definitions/restLockInfo"
        },
        "ContentType": {
          "type": "string"
        },
        "ContentsHash": {
          "type": "string"
        },
        "ContextWorkspace": {
          "$ref": "#/definitions/restContextWorkspace"
        },
        "DataSourceFeatures": {
          "$ref": "#/definitions/restDataSourceFeatures"
        },
        "FolderMeta": {
          "items": {
            "$ref": "#/definitions/restCountMeta",
            "type": "object"
          },
          "type": "array"
        },
        "HashingMethod": {
          "type": "string"
        },
        "ImageMeta": {
          "$ref": "#/definitions/restImageMeta"
        },
        "IsBookmarked": {
          "type": "boolean"
        },
        "IsRecycleBin": {
          "type": "boolean"
        },
        "IsRecycled": {
          "type": "boolean"
        },
        "Metadata": {
          "items": {
            "$ref": "#/definitions/restJsonMeta",
            "type": "object"
          },
          "type": "array"
        },
        "Mode": {
          "$ref": "#/definitions/restMode"
        },
        "Modified": {
          "format": "int64",
          "title": "Date instead of TS ?",
          "type": "string"
        },
        "Path": {
          "type": "string"
        },
        "Previews": {
          "items": {
            "$ref": "#/definitions/restFilePreview",
            "type": "object"
          },
          "type": "array"
        },
        "Shares": {
          "items": {
            "$ref": "#/definitions/restShareLink",
            "type": "object"
          },
          "type": "array"
        },
        "Size": {
          "format": "int64",
          "type": "string"
        },
        "StorageETag": {
          "type": "string"
        },
        "Subscriptions": {
          "items": {
            "$ref": "#/definitions/activitySubscription",
            "type": "object"
          },
          "type": "array"
        },
        "Type": {
          "$ref": "#/definitions/treeNodeType"
        },
        "UserMetadata": {
          "items": {
            "$ref": "#/definitions/restJsonMeta",
            "type": "object"
          },
          "type": "array"
        },
        "Uuid": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restNodeCollection": {
      "properties": {
        "Facets": {
          "items": {
            "$ref": "#/definitions/treeSearchFacet",
            "type": "object"
          },
          "type": "array"
        },
        "Nodes": {
          "items": {
            "$ref": "#/definitions/restNode",
            "type": "object"
          },
          "type": "array"
        },
        "Pagination": {
          "$ref": "#/definitions/restPagination"
        }
      },
      "type": "object"
    },
    "restNodeLocator": {
      "properties": {
        "Path": {
          "type": "string"
        },
        "Uuid": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restNodesCollection": {
      "properties": {
        "Children": {
          "items": {
            "$ref": "#/definitions/treeNode",
            "type": "object"
          },
          "type": "array"
        },
        "Parent": {
          "$ref": "#/definitions/treeNode"
        }
      },
      "type": "object"
    },
    "restPagination": {
      "properties": {
        "CurrentOffset": {
          "format": "int32",
          "title": "Current Offset value",
          "type": "integer"
        },
        "CurrentPage": {
          "format": "int32",
          "title": "Current number of Page",
          "type": "integer"
        },
        "Limit": {
          "format": "int32",
          "title": "Current Limit parameter, either passed by request or default value",
          "type": "integer"
        },
        "NextOffset": {
          "format": "int32",
          "title": "Offset value for next page if there is one",
          "type": "integer"
        },
        "PrevOffset": {
          "format": "int32",
          "title": "Offset value for previous page, if there is one",
          "type": "integer"
        },
        "Total": {
          "format": "int32",
          "title": "Total number of records",
          "type": "integer"
        },
        "TotalPages": {
          "format": "int32",
          "title": "Number of detected pages",
          "type": "integer"
        }
      },
      "title": "Generic container for responses sending pagination information",
      "type": "object"
    },
    "restPublicLinkDeleteSuccess": {
      "properties": {
        "Message": {
          "type": "string"
        },
        "Uuid": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restSelection": {
      "properties": {
        "Nodes": {
          "items": {
            "$ref": "#/definitions/restNode",
            "type": "object"
          },
          "type": "array"
        },
        "Uuid": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restShareLink": {
      "properties": {
        "AccessEnd": {
          "format": "int64",
          "title": "Timestamp after which the share is disabled",
          "type": "string"
        },
        "AccessStart": {
          "format": "int64",
          "title": "Timestamp of start date for enabling the share (not implemented yet)",
          "type": "string"
        },
        "CurrentDownloads": {
          "format": "int64",
          "title": "Current number of downloads",
          "type": "string"
        },
        "Description": {
          "title": "Description of the Link (max 1000 chars)",
          "type": "string"
        },
        "Label": {
          "title": "Label of the Link (max 500 chars)",
          "type": "string"
        },
        "LinkHash": {
          "title": "Unique Hash for accessing the link",
          "type": "string"
        },
        "LinkUrl": {
          "title": "Full URL for accessing the link",
          "type": "string"
        },
        "MaxDownloads": {
          "format": "int64",
          "title": "Maximum number of downloads until expiration",
          "type": "string"
        },
        "PasswordRequired": {
          "title": "Whether a password is required or not to access the link",
          "type": "boolean"
        },
        "Permissions": {
          "items": {
            "$ref": "#/definitions/restShareLinkAccessType"
          },
          "title": "Specific permissions for public links",
          "type": "array"
        },
        "Policies": {
          "items": {
            "$ref": "#/definitions/serviceResourcePolicy",
            "type": "object"
          },
          "title": "Security policies",
          "type": "array"
        },
        "PoliciesContextEditable": {
          "title": "Whether policies are currently editable or not",
          "type": "boolean"
        },
        "RestrictToTargetUsers": {
          "title": "RestrictToTargetUsers enable users restriction",
          "type": "boolean"
        },
        "RootNodes": {
          "items": {
            "$ref": "#/definitions/treeNode",
            "type": "object"
          },
          "title": "Nodes in the tree that serve as root to this link",
          "type": "array"
        },
        "TargetUsers": {
          "additionalProperties": {
            "$ref": "#/definitions/restShareLinkTargetUser"
          },
          "title": "TargetUsers can be used to restrict access",
          "type": "object"
        },
        "UserLogin": {
          "title": "Temporary user Login used to login automatically when accessing this link",
          "type": "string"
        },
        "UserUuid": {
          "title": "Temporary user Uuid used to login automatically when accessing this link",
          "type": "string"
        },
        "Uuid": {
          "title": "Internal identifier of the link",
          "type": "string"
        },
        "ViewTemplateName": {
          "title": "Display Template for loading the public link",
          "type": "string"
        }
      },
      "title": "Model for representing a public link",
      "type": "object"
    },
    "restShareLinkAccessType": {
      "default": "NoAccess",
      "enum": [
        "NoAccess",
        "Preview",
        "Download",
        "Upload"
      ],
      "title": "Known values for link permissions",
      "type": "string"
    },
    "restShareLinkTargetUser": {
      "properties": {
        "Display": {
          "type": "string"
        },
        "DownloadCount": {
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "restTemplate": {
      "properties": {
        "Editable": {
          "title": "Whether this template can be edited or not",
          "type": "boolean"
        },
        "Label": {
          "title": "Human friendly label",
          "type": "string"
        },
        "Node": {
          "$ref": "#/definitions/restTemplateNode",
          "title": "Template node, can be a file or a tree of folders"
        },
        "Policies": {
          "items": {
            "$ref": "#/definitions/serviceResourcePolicy",
            "type": "object"
          },
          "title": "Associated policies",
          "type": "array"
        },
        "UUID": {
          "title": "Unique identifier for this template",
          "type": "string"
        }
      },
      "title": "A template can be used to create files or tree from scratch",
      "type": "object"
    },
    "restTemplateNode": {
      "properties": {
        "Children": {
          "additionalProperties": {
            "$ref": "#/definitions/treeNode"
          },
          "title": "One or more children",
          "type": "object"
        },
        "Node": {
          "$ref": "#/definitions/treeNode",
          "title": "Whether it's a file or a folder"
        }
      },
      "title": "A template node is representing a file or a folder",
      "type": "object"
    },
    "restUpsertPublicLinkRequest": {
      "properties": {
        "CreatePassword": {
          "title": "Set if switching from no password to password",
          "type": "string"
        },
        "Link": {
          "$ref": "#/definitions/restShareLink"
        },
        "PasswordEnabled": {
          "title": "Whether it has Password enabled",
          "type": "boolean"
        },
        "UpdateCustomHash": {
          "title": "Change the ShareLink Hash with a custom value",
          "type": "string"
        },
        "UpdatePassword": {
          "title": "Set if updating an existing password",
          "type": "string"
        },
        "Uuid": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "restUserActionType": {
      "default": "delete",
      "enum": [
        "delete",
        "restore",
        "copy",
        "move",
        "extract",
        "compress"
      ],
      "type": "string"
    },
    "serviceOperationType": {
      "default": "OR",
      "enum": [
        "OR",
        "AND"
      ],
      "type": "string"
    },
    "serviceQuery": {
      "properties": {
        "Limit": {
          "format": "int64",
          "type": "string"
        },
        "Offset": {
          "format": "int64",
          "type": "string"
        },
        "Operation": {
          "$ref": "#/definitions/serviceOperationType"
        },
        "ResourcePolicyQuery": {
          "$ref": "#/definitions/serviceResourcePolicyQuery"
        },
        "SortDesc": {
          "type": "boolean"
        },
        "SortField": {
          "type": "string"
        },
        "SubQueries": {
          "items": {
            "$ref": "#/definitions/protobufAny",
            "type": "object"
          },
          "type": "array"
        },
        "groupBy": {
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "serviceResourcePolicy": {
      "properties": {
        "Action": {
          "$ref": "#/definitions/serviceResourcePolicyAction"
        },
        "Effect": {
          "$ref": "#/definitions/serviceResourcePolicyPolicyEffect"
        },
        "JsonConditions": {
          "type": "string"
        },
        "Resource": {
          "type": "string"
        },
        "Subject": {
          "type": "string"
        },
        "id": {
          "format": "int64",
          "type": "string"
        }
      },
      "type": "object"
    },
    "serviceResourcePolicyAction": {
      "default": "ANY",
      "enum": [
        "ANY",
        "OWNER",
        "READ",
        "WRITE",
        "EDIT_RULES"
      ],
      "type": "string"
    },
    "serviceResourcePolicyPolicyEffect": {
      "default": "deny",
      "enum": [
        "deny",
        "allow"
      ],
      "type": "string"
    },
    "serviceResourcePolicyQuery": {
      "properties": {
        "Action": {
          "$ref": "#/definitions/serviceResourcePolicyAction"
        },
        "Any": {
          "type": "boolean"
        },
        "Empty": {
          "type": "boolean"
        },
        "LeftIdentifier": {
          "type": "string"
        },
        "Subjects": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "treeChangeLog": {
      "properties": {
        "Data": {
          "format": "byte",
          "title": "Arbitrary additional data",
          "type": "string"
        },
        "Description": {
          "title": "Human-readable description of what happened",
          "type": "string"
        },
        "Event": {
          "$ref": "#/definitions/treeNodeChangeEvent",
          "title": "Event that triggered this change"
        },
        "Location": {
          "$ref": "#/definitions/treeNode",
          "title": "Actual location of the stored version"
        },
        "MTime": {
          "format": "int64",
          "title": "Unix Timestamp",
          "type": "string"
        },
        "OwnerUuid": {
          "title": "Who performed this action",
          "type": "string"
        },
        "Size": {
          "format": "int64",
          "title": "Content Size at that moment",
          "type": "string"
        },
        "Uuid": {
          "title": "Unique commit ID",
          "type": "string"
        }
      },
      "type": "object"
    },
    "treeGeoPoint": {
      "properties": {
        "Lat": {
          "format": "double",
          "type": "number"
        },
        "Lon": {
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "treeGeoQuery": {
      "properties": {
        "BottomRight": {
          "$ref": "#/definitions/treeGeoPoint"
        },
        "Center": {
          "$ref": "#/definitions/treeGeoPoint",
          "title": "Either use a center point and a distance"
        },
        "Distance": {
          "description": "Example formats supported:\n\"5in\" \"5inch\" \"7yd\" \"7yards\" \"9ft\" \"9feet\" \"11km\" \"11kilometers\"\n\"3nm\" \"3nauticalmiles\" \"13mm\" \"13millimeters\" \"15cm\" \"15centimeters\"\n\"17mi\" \"17miles\" \"19m\" \"19meters\"\nIf the unit cannot be determined, the entire string is parsed and the\nunit of meters is assumed.",
          "type": "string"
        },
        "TopLeft": {
          "$ref": "#/definitions/treeGeoPoint",
          "title": "Or use a bounding box with TopLeft and BottomRight points"
        }
      },
      "type": "object"
    },
    "treeNode": {
      "properties": {
        "AppearsIn": {
          "items": {
            "$ref": "#/definitions/treeWorkspaceRelativePath",
            "type": "object"
          },
          "title": "Can be used for output when node is appearing in multiple workspaces",
          "type": "array"
        },
        "Commits": {
          "items": {
            "$ref": "#/definitions/treeChangeLog",
            "type": "object"
          },
          "title": "List of successive commits",
          "type": "array"
        },
        "Etag": {
          "title": "Hash of the content if node is a LEAF, Uuid or",
          "type": "string"
        },
        "MTime": {
          "format": "int64",
          "title": "Last modification Timestamp",
          "type": "string"
        },
        "MetaStore": {
          "additionalProperties": {
            "type": "string"
          },
          "title": "------------------------------------\nThen a free K =\u003e V representation of any kind of metadata\n------------------------------------",
          "type": "object"
        },
        "Mode": {
          "description": "Permission mode, like 0777. Stored as string using custom ModeString field.",
          "format": "int32",
          "type": "integer"
        },
        "ModeString": {
          "title": "String representation of Mode",
          "type": "string"
        },
        "Path": {
          "type": "string"
        },
        "Size": {
          "format": "int64",
          "title": "Size of the file, or cumulated size of folder",
          "type": "string"
        },
        "Type": {
          "$ref": "#/definitions/treeNodeType"
        },
        "Uuid": {
          "title": "------------------------------------\nCore identification of the node\n------------------------------------",
          "type": "string"
        }
      },
      "type": "object"
    },
    "treeNodeChangeEvent": {
      "properties": {
        "Metadata": {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        },
        "Optimistic": {
          "type": "boolean"
        },
        "Silent": {
          "type": "boolean"
        },
        "Source": {
          "$ref": "#/definitions/treeNode"
        },
        "Target": {
          "$ref": "#/definitions/treeNode"
        },
        "Type": {
          "$ref": "#/definitions/treeNodeChangeEventEventType"
        }
      },
      "type": "object"
    },
    "treeNodeChangeEventEventType": {
      "default": "CREATE",
      "enum": [
        "CREATE",
        "READ",
        "UPDATE_PATH",
        "UPDATE_CONTENT",
        "UPDATE_META",
        "UPDATE_USER_META",
        "DELETE"
      ],
      "type": "string"
    },
    "treeNodeType": {
      "default": "UNKNOWN",
      "enum": [
        "UNKNOWN",
        "LEAF",
        "COLLECTION"
      ],
      "title": "==========================================================\n* Standard Messages\n==========================================================",
      "type": "string"
    },
    "treeQuery": {
      "properties": {
        "Content": {
          "title": "Search in textual content (if search engine has this feature enabled)",
          "type": "string"
        },
        "DurationDate": {
          "title": "Compute MinDate/MaxDate with a Golang duration with a leading comparator (\u003e or \u003c)\nDuration may contain \"s\" second, \"m\" minute, \"d\" day.\nExample: \"\u003e10m\" for files modified before 10minutes ago",
          "type": "string"
        },
        "ETag": {
          "title": "Look for a specific ETag value, may only be useful to lookup for files with __temporary__ ETag",
          "type": "string"
        },
        "Extension": {
          "title": "Search files by their extension, use pipe symbol | if you wish to allow many extensions.\nExample png|pdf|jpg",
          "type": "string"
        },
        "FileName": {
          "title": "Lookup by file basename",
          "type": "string"
        },
        "FileNameOrContent": {
          "title": "Search in either filename or content (if search engine has this feature enabled)",
          "type": "string"
        },
        "FreeString": {
          "description": "Bleve-like search query to search for a specific metadata value.\nWhen querying nodes, this will redirect this query to the Search Engine. When filtering an input, this will load an in-memory bleve engine to evaluate the node.\n\nBleve query string format is a space separated list of `[+-]key:value`, where node meta keys must be prepended with \"Meta.\"\nFor Example, for tags: `+Meta.usermeta-tags:myvalue`",
          "type": "string"
        },
        "GeoQuery": {
          "$ref": "#/definitions/treeGeoQuery",
          "title": "Search geographically"
        },
        "MaxDate": {
          "format": "int64",
          "title": "Range for modification date - node was modified before this date",
          "type": "string"
        },
        "MaxSize": {
          "format": "int64",
          "title": "Range for file size - size is smaller than",
          "type": "string"
        },
        "MinDate": {
          "format": "int64",
          "title": "Range for modification date - node was modified after this date",
          "type": "string"
        },
        "MinSize": {
          "format": "int64",
          "title": "Range for file size - size bigger than",
          "type": "string"
        },
        "Not": {
          "title": "Negate this query",
          "type": "boolean"
        },
        "PathDepth": {
          "format": "int32",
          "title": "Restrict recursive listing to a given level of the tree starting from root.\nSpecial value \"-1\" should list only one level in the folder defined by PathPrefix",
          "type": "integer"
        },
        "PathPrefix": {
          "items": {
            "type": "string"
          },
          "title": "Recursive listing of nodes below a given path. Combine with the PathDepth parameter to limit request results",
          "type": "array"
        },
        "Paths": {
          "items": {
            "type": "string"
          },
          "title": "List of nodes paths, exactly matching",
          "type": "array"
        },
        "Type": {
          "$ref": "#/definitions/treeNodeType",
          "title": "Limit to a given node type (file or folder)"
        },
        "UUIDs": {
          "items": {
            "type": "string"
          },
          "title": "Preset list of specific node defined by their UUIDs",
          "type": "array"
        }
      },
      "title": "Search Queries",
      "type": "object"
    },
    "treeSearchFacet": {
      "properties": {
        "Count": {
          "format": "int32",
          "title": "Segment results count",
          "type": "integer"
        },
        "End": {
          "format": "int32",
          "type": "integer"
        },
        "FieldName": {
          "title": "Facet field name",
          "type": "string"
        },
        "Label": {
          "title": "Segment Label",
          "type": "string"
        },
        "Max": {
          "format": "int64",
          "type": "string"
        },
        "Min": {
          "format": "int64",
          "title": "For NumericRange facets, min/max values",
          "type": "string"
        },
        "Start": {
          "format": "int32",
          "title": "For DateRange facets, start/end values",
          "type": "integer"
        },
        "Term": {
          "title": "For string facets, term value",
          "type": "string"
        }
      },
      "type": "object"
    },
    "treeWorkspaceRelativePath": {
      "properties": {
        "Path": {
          "title": "Relative Path inside workspace",
          "type": "string"
        },
        "WsLabel": {
          "title": "Workspace Label",
          "type": "string"
        },
        "WsScope": {
          "title": "Workspace Scope",
          "type": "string"
        },
        "WsSlug": {
          "title": "Workspace slug",
          "type": "string"
        },
        "WsUuid": {
          "title": "Workspace Id",
          "type": "string"
        }
      },
      "title": "Used in AppearsIn to signal a node is\nappearing in multiple workspaces in the current context",
      "type": "object"
    }
  },
  "externalDocs": {
    "description": "More about Pydio Cells Apis",
    "url": "https://pydio.com"
  },
  "info": {
    "contact": {
      "name": "Pydio",
      "url": "https://pydio.com"
    },
    "title": "Pydio Cells Rest API",
    "version": "v2"
  },
  "paths": {
    "/node": {
      "post": {
        "operationId": "Lookup",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/restLookupRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restNodesCollection"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Generic request to either list (using Locators) or search (using Query) for nodes",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/action/{Name}": {
      "post": {
        "operationId": "PerformAction",
        "parameters": [
          {
            "enum": [
              "delete",
              "restore",
              "copy",
              "move",
              "extract",
              "compress"
            ],
            "in": "path",
            "name": "Name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "Parameters",
            "required": true,
            "schema": {
              "$ref": "#/definitions/restActionParameters"
            }
          },
          {
            "in": "query",
            "name": "JobUuid",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restActionResponse"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Trigger an action on the tree. Returns a JobInfo describing a background task.",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/action/{Name}/{JobUuid}": {
      "get": {
        "operationId": "GetActionJob",
        "parameters": [
          {
            "enum": [
              "delete",
              "restore",
              "copy",
              "move",
              "extract",
              "compress"
            ],
            "in": "path",
            "name": "Name",
            "required": true,
            "type": "string"
          },
          {
            "in": "path",
            "name": "JobUuid",
            "required": true,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Parameters.TargetNode.Uuid",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Parameters.TargetNode.Path",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Parameters.SelectionUuid",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Parameters.JsonParameters",
            "required": false,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Parameters.Await",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jobsJob"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Retrieve information about an action running in background",
        "tags": [
          "NodeService"
        ]
      },
      "patch": {
        "operationId": "ControlActionJob",
        "parameters": [
          {
            "enum": [
              "delete",
              "restore",
              "copy",
              "move",
              "extract",
              "compress"
            ],
            "in": "path",
            "name": "Name",
            "required": true,
            "type": "string"
          },
          {
            "in": "path",
            "name": "JobUuid",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "Command",
            "required": true,
            "schema": {
              "$ref": "#/definitions/jobsCtrlCommand"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/jobsJob"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Send control commands to a background job",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/create": {
      "post": {
        "operationId": "Create",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/restCreateRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restNodesCollection"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Create one or many files (empty or hydrated from a TemplateUuid) or folders",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/link": {
      "post": {
        "operationId": "CreatePublicLink",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/restUpsertPublicLinkRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restShareLink"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Create a public link on a given node",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/link/{Uuid}": {
      "delete": {
        "operationId": "DeletePublicLink",
        "parameters": [
          {
            "in": "path",
            "name": "Uuid",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restPublicLinkDeleteSuccess"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Remove a public link",
        "tags": [
          "NodeService"
        ]
      },
      "get": {
        "operationId": "GetPublicLink",
        "parameters": [
          {
            "in": "path",
            "name": "Uuid",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restShareLink"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Load public link information by Uuid",
        "tags": [
          "NodeService"
        ]
      },
      "patch": {
        "operationId": "UpdatePublicLink",
        "parameters": [
          {
            "in": "path",
            "name": "Uuid",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "Link",
            "required": true,
            "schema": {
              "$ref": "#/definitions/restShareLink"
            }
          },
          {
            "description": "Whether it has Password enabled",
            "in": "query",
            "name": "PasswordEnabled",
            "required": false,
            "type": "boolean"
          },
          {
            "description": "Set if switching from no password to password",
            "in": "query",
            "name": "CreatePassword",
            "required": false,
            "type": "string"
          },
          {
            "description": "Set if updating an existing password",
            "in": "query",
            "name": "UpdatePassword",
            "required": false,
            "type": "string"
          },
          {
            "description": "Change the ShareLink Hash with a custom value",
            "in": "query",
            "name": "UpdateCustomHash",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restShareLink"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Update public link settings",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/p/{Path}": {
      "get": {
        "operationId": "GetByPath",
        "parameters": [
          {
            "in": "path",
            "name": "Path",
            "required": true,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Uuid",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restNode"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Load a node by its path",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/selection": {
      "post": {
        "operationId": "CreateSelection",
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/restSelection"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restSelection"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Create and persist a temporary selection of nodes, that can be used by other actions",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/templates": {
      "get": {
        "operationId": "Templates",
        "parameters": [
          {
            "in": "query",
            "name": "TemplateType",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restListTemplatesResponse"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "List available templates for hydrating empty files",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/u/{Uuid}": {
      "get": {
        "operationId": "GetByUuid",
        "parameters": [
          {
            "in": "path",
            "name": "Uuid",
            "required": true,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Path",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restNode"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "Load a node by its Uuid",
        "tags": [
          "NodeService"
        ]
      }
    },
    "/node/v/{Uuid}": {
      "get": {
        "operationId": "ListVersions",
        "parameters": [
          {
            "in": "path",
            "name": "Uuid",
            "required": true,
            "type": "string"
          },
          {
            "in": "query",
            "name": "Path",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/restNodeCollection"
            }
          },
          "401": {
            "description": "User is not authenticated",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "403": {
            "description": "User has no permission to access this particular resource",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "404": {
            "description": "Resource does not exist in the system",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          },
          "500": {
            "description": "An internal error occurred in the backend",
            "schema": {
              "$ref": "#/definitions/restError"
            }
          }
        },
        "summary": "List all known versions of a node",
        "tags": [
          "NodeService"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https",
    "wss"
  ],
  "swagger": "2.0",
  "tags": [
    {
      "name": "NodeService"
    }
  ]
}