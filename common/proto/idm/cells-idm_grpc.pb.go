// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package idm

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RoleServiceClient is the client API for RoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleServiceClient interface {
	CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*CreateRoleResponse, error)
	DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*DeleteRoleResponse, error)
	SearchRole(ctx context.Context, in *SearchRoleRequest, opts ...grpc.CallOption) (RoleService_SearchRoleClient, error)
	StreamRole(ctx context.Context, opts ...grpc.CallOption) (RoleService_StreamRoleClient, error)
	CountRole(ctx context.Context, in *SearchRoleRequest, opts ...grpc.CallOption) (*CountRoleResponse, error)
}

type roleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleServiceClient(cc grpc.ClientConnInterface) RoleServiceClient {
	return &roleServiceClient{cc}
}

func (c *roleServiceClient) CreateRole(ctx context.Context, in *CreateRoleRequest, opts ...grpc.CallOption) (*CreateRoleResponse, error) {
	out := new(CreateRoleResponse)
	err := c.cc.Invoke(ctx, "/idm.RoleService/CreateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) DeleteRole(ctx context.Context, in *DeleteRoleRequest, opts ...grpc.CallOption) (*DeleteRoleResponse, error) {
	out := new(DeleteRoleResponse)
	err := c.cc.Invoke(ctx, "/idm.RoleService/DeleteRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) SearchRole(ctx context.Context, in *SearchRoleRequest, opts ...grpc.CallOption) (RoleService_SearchRoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &RoleService_ServiceDesc.Streams[0], "/idm.RoleService/SearchRole", opts...)
	if err != nil {
		return nil, err
	}
	x := &roleServiceSearchRoleClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RoleService_SearchRoleClient interface {
	Recv() (*SearchRoleResponse, error)
	grpc.ClientStream
}

type roleServiceSearchRoleClient struct {
	grpc.ClientStream
}

func (x *roleServiceSearchRoleClient) Recv() (*SearchRoleResponse, error) {
	m := new(SearchRoleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *roleServiceClient) StreamRole(ctx context.Context, opts ...grpc.CallOption) (RoleService_StreamRoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &RoleService_ServiceDesc.Streams[1], "/idm.RoleService/StreamRole", opts...)
	if err != nil {
		return nil, err
	}
	x := &roleServiceStreamRoleClient{stream}
	return x, nil
}

type RoleService_StreamRoleClient interface {
	Send(*SearchRoleRequest) error
	Recv() (*SearchRoleResponse, error)
	grpc.ClientStream
}

type roleServiceStreamRoleClient struct {
	grpc.ClientStream
}

func (x *roleServiceStreamRoleClient) Send(m *SearchRoleRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *roleServiceStreamRoleClient) Recv() (*SearchRoleResponse, error) {
	m := new(SearchRoleResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *roleServiceClient) CountRole(ctx context.Context, in *SearchRoleRequest, opts ...grpc.CallOption) (*CountRoleResponse, error) {
	out := new(CountRoleResponse)
	err := c.cc.Invoke(ctx, "/idm.RoleService/CountRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServiceServer is the server API for RoleService service.
// All implementations must embed UnimplementedRoleServiceServer
// for forward compatibility
type RoleServiceServer interface {
	CreateRole(context.Context, *CreateRoleRequest) (*CreateRoleResponse, error)
	DeleteRole(context.Context, *DeleteRoleRequest) (*DeleteRoleResponse, error)
	SearchRole(*SearchRoleRequest, RoleService_SearchRoleServer) error
	StreamRole(RoleService_StreamRoleServer) error
	CountRole(context.Context, *SearchRoleRequest) (*CountRoleResponse, error)
	mustEmbedUnimplementedRoleServiceServer()
}

// UnimplementedRoleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServiceServer struct {
}

func (UnimplementedRoleServiceServer) CreateRole(context.Context, *CreateRoleRequest) (*CreateRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedRoleServiceServer) DeleteRole(context.Context, *DeleteRoleRequest) (*DeleteRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServiceServer) SearchRole(*SearchRoleRequest, RoleService_SearchRoleServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchRole not implemented")
}
func (UnimplementedRoleServiceServer) StreamRole(RoleService_StreamRoleServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamRole not implemented")
}
func (UnimplementedRoleServiceServer) CountRole(context.Context, *SearchRoleRequest) (*CountRoleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountRole not implemented")
}
func (UnimplementedRoleServiceServer) mustEmbedUnimplementedRoleServiceServer() {}

// UnsafeRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServiceServer will
// result in compilation errors.
type UnsafeRoleServiceServer interface {
	mustEmbedUnimplementedRoleServiceServer()
}

func RegisterRoleServiceServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	s.RegisterService(&RoleService_ServiceDesc, srv)
}

func _RoleService_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.RoleService/CreateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).CreateRole(ctx, req.(*CreateRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.RoleService/DeleteRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).DeleteRole(ctx, req.(*DeleteRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_SearchRole_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRoleRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RoleServiceServer).SearchRole(m, &roleServiceSearchRoleServer{stream})
}

type RoleService_SearchRoleServer interface {
	Send(*SearchRoleResponse) error
	grpc.ServerStream
}

type roleServiceSearchRoleServer struct {
	grpc.ServerStream
}

func (x *roleServiceSearchRoleServer) Send(m *SearchRoleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RoleService_StreamRole_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RoleServiceServer).StreamRole(&roleServiceStreamRoleServer{stream})
}

type RoleService_StreamRoleServer interface {
	Send(*SearchRoleResponse) error
	Recv() (*SearchRoleRequest, error)
	grpc.ServerStream
}

type roleServiceStreamRoleServer struct {
	grpc.ServerStream
}

func (x *roleServiceStreamRoleServer) Send(m *SearchRoleResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *roleServiceStreamRoleServer) Recv() (*SearchRoleRequest, error) {
	m := new(SearchRoleRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RoleService_CountRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).CountRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.RoleService/CountRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).CountRole(ctx, req.(*SearchRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleService_ServiceDesc is the grpc.ServiceDesc for RoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idm.RoleService",
	HandlerType: (*RoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRole",
			Handler:    _RoleService_CreateRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _RoleService_DeleteRole_Handler,
		},
		{
			MethodName: "CountRole",
			Handler:    _RoleService_CountRole_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchRole",
			Handler:       _RoleService_SearchRole_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamRole",
			Handler:       _RoleService_StreamRole_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-idm.proto",
}

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
	BindUser(ctx context.Context, in *BindUserRequest, opts ...grpc.CallOption) (*BindUserResponse, error)
	CountUser(ctx context.Context, in *SearchUserRequest, opts ...grpc.CallOption) (*CountUserResponse, error)
	SearchUser(ctx context.Context, in *SearchUserRequest, opts ...grpc.CallOption) (UserService_SearchUserClient, error)
	StreamUser(ctx context.Context, opts ...grpc.CallOption) (UserService_StreamUserClient, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
	out := new(CreateUserResponse)
	err := c.cc.Invoke(ctx, "/idm.UserService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error) {
	out := new(DeleteUserResponse)
	err := c.cc.Invoke(ctx, "/idm.UserService/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) BindUser(ctx context.Context, in *BindUserRequest, opts ...grpc.CallOption) (*BindUserResponse, error) {
	out := new(BindUserResponse)
	err := c.cc.Invoke(ctx, "/idm.UserService/BindUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CountUser(ctx context.Context, in *SearchUserRequest, opts ...grpc.CallOption) (*CountUserResponse, error) {
	out := new(CountUserResponse)
	err := c.cc.Invoke(ctx, "/idm.UserService/CountUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) SearchUser(ctx context.Context, in *SearchUserRequest, opts ...grpc.CallOption) (UserService_SearchUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &UserService_ServiceDesc.Streams[0], "/idm.UserService/SearchUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceSearchUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserService_SearchUserClient interface {
	Recv() (*SearchUserResponse, error)
	grpc.ClientStream
}

type userServiceSearchUserClient struct {
	grpc.ClientStream
}

func (x *userServiceSearchUserClient) Recv() (*SearchUserResponse, error) {
	m := new(SearchUserResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userServiceClient) StreamUser(ctx context.Context, opts ...grpc.CallOption) (UserService_StreamUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &UserService_ServiceDesc.Streams[1], "/idm.UserService/StreamUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceStreamUserClient{stream}
	return x, nil
}

type UserService_StreamUserClient interface {
	Send(*SearchUserRequest) error
	Recv() (*SearchUserResponse, error)
	grpc.ClientStream
}

type userServiceStreamUserClient struct {
	grpc.ClientStream
}

func (x *userServiceStreamUserClient) Send(m *SearchUserRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userServiceStreamUserClient) Recv() (*SearchUserResponse, error) {
	m := new(SearchUserResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
	BindUser(context.Context, *BindUserRequest) (*BindUserResponse, error)
	CountUser(context.Context, *SearchUserRequest) (*CountUserResponse, error)
	SearchUser(*SearchUserRequest, UserService_SearchUserServer) error
	StreamUser(UserService_StreamUserServer) error
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) BindUser(context.Context, *BindUserRequest) (*BindUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindUser not implemented")
}
func (UnimplementedUserServiceServer) CountUser(context.Context, *SearchUserRequest) (*CountUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CountUser not implemented")
}
func (UnimplementedUserServiceServer) SearchUser(*SearchUserRequest, UserService_SearchUserServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchUser not implemented")
}
func (UnimplementedUserServiceServer) StreamUser(UserService_StreamUserServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.UserService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.UserService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_BindUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BindUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).BindUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.UserService/BindUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).BindUser(ctx, req.(*BindUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CountUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CountUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.UserService/CountUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CountUser(ctx, req.(*SearchUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_SearchUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchUserRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserServiceServer).SearchUser(m, &userServiceSearchUserServer{stream})
}

type UserService_SearchUserServer interface {
	Send(*SearchUserResponse) error
	grpc.ServerStream
}

type userServiceSearchUserServer struct {
	grpc.ServerStream
}

func (x *userServiceSearchUserServer) Send(m *SearchUserResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserService_StreamUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserServiceServer).StreamUser(&userServiceStreamUserServer{stream})
}

type UserService_StreamUserServer interface {
	Send(*SearchUserResponse) error
	Recv() (*SearchUserRequest, error)
	grpc.ServerStream
}

type userServiceStreamUserServer struct {
	grpc.ServerStream
}

func (x *userServiceStreamUserServer) Send(m *SearchUserResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userServiceStreamUserServer) Recv() (*SearchUserRequest, error) {
	m := new(SearchUserRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idm.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "BindUser",
			Handler:    _UserService_BindUser_Handler,
		},
		{
			MethodName: "CountUser",
			Handler:    _UserService_CountUser_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchUser",
			Handler:       _UserService_SearchUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamUser",
			Handler:       _UserService_StreamUser_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-idm.proto",
}

// WorkspaceServiceClient is the client API for WorkspaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkspaceServiceClient interface {
	CreateWorkspace(ctx context.Context, in *CreateWorkspaceRequest, opts ...grpc.CallOption) (*CreateWorkspaceResponse, error)
	DeleteWorkspace(ctx context.Context, in *DeleteWorkspaceRequest, opts ...grpc.CallOption) (*DeleteWorkspaceResponse, error)
	SearchWorkspace(ctx context.Context, in *SearchWorkspaceRequest, opts ...grpc.CallOption) (WorkspaceService_SearchWorkspaceClient, error)
	StreamWorkspace(ctx context.Context, opts ...grpc.CallOption) (WorkspaceService_StreamWorkspaceClient, error)
}

type workspaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkspaceServiceClient(cc grpc.ClientConnInterface) WorkspaceServiceClient {
	return &workspaceServiceClient{cc}
}

func (c *workspaceServiceClient) CreateWorkspace(ctx context.Context, in *CreateWorkspaceRequest, opts ...grpc.CallOption) (*CreateWorkspaceResponse, error) {
	out := new(CreateWorkspaceResponse)
	err := c.cc.Invoke(ctx, "/idm.WorkspaceService/CreateWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceServiceClient) DeleteWorkspace(ctx context.Context, in *DeleteWorkspaceRequest, opts ...grpc.CallOption) (*DeleteWorkspaceResponse, error) {
	out := new(DeleteWorkspaceResponse)
	err := c.cc.Invoke(ctx, "/idm.WorkspaceService/DeleteWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceServiceClient) SearchWorkspace(ctx context.Context, in *SearchWorkspaceRequest, opts ...grpc.CallOption) (WorkspaceService_SearchWorkspaceClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorkspaceService_ServiceDesc.Streams[0], "/idm.WorkspaceService/SearchWorkspace", opts...)
	if err != nil {
		return nil, err
	}
	x := &workspaceServiceSearchWorkspaceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorkspaceService_SearchWorkspaceClient interface {
	Recv() (*SearchWorkspaceResponse, error)
	grpc.ClientStream
}

type workspaceServiceSearchWorkspaceClient struct {
	grpc.ClientStream
}

func (x *workspaceServiceSearchWorkspaceClient) Recv() (*SearchWorkspaceResponse, error) {
	m := new(SearchWorkspaceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workspaceServiceClient) StreamWorkspace(ctx context.Context, opts ...grpc.CallOption) (WorkspaceService_StreamWorkspaceClient, error) {
	stream, err := c.cc.NewStream(ctx, &WorkspaceService_ServiceDesc.Streams[1], "/idm.WorkspaceService/StreamWorkspace", opts...)
	if err != nil {
		return nil, err
	}
	x := &workspaceServiceStreamWorkspaceClient{stream}
	return x, nil
}

type WorkspaceService_StreamWorkspaceClient interface {
	Send(*SearchWorkspaceRequest) error
	Recv() (*SearchWorkspaceResponse, error)
	grpc.ClientStream
}

type workspaceServiceStreamWorkspaceClient struct {
	grpc.ClientStream
}

func (x *workspaceServiceStreamWorkspaceClient) Send(m *SearchWorkspaceRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *workspaceServiceStreamWorkspaceClient) Recv() (*SearchWorkspaceResponse, error) {
	m := new(SearchWorkspaceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WorkspaceServiceServer is the server API for WorkspaceService service.
// All implementations must embed UnimplementedWorkspaceServiceServer
// for forward compatibility
type WorkspaceServiceServer interface {
	CreateWorkspace(context.Context, *CreateWorkspaceRequest) (*CreateWorkspaceResponse, error)
	DeleteWorkspace(context.Context, *DeleteWorkspaceRequest) (*DeleteWorkspaceResponse, error)
	SearchWorkspace(*SearchWorkspaceRequest, WorkspaceService_SearchWorkspaceServer) error
	StreamWorkspace(WorkspaceService_StreamWorkspaceServer) error
	mustEmbedUnimplementedWorkspaceServiceServer()
}

// UnimplementedWorkspaceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedWorkspaceServiceServer struct {
}

func (UnimplementedWorkspaceServiceServer) CreateWorkspace(context.Context, *CreateWorkspaceRequest) (*CreateWorkspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorkspace not implemented")
}
func (UnimplementedWorkspaceServiceServer) DeleteWorkspace(context.Context, *DeleteWorkspaceRequest) (*DeleteWorkspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkspace not implemented")
}
func (UnimplementedWorkspaceServiceServer) SearchWorkspace(*SearchWorkspaceRequest, WorkspaceService_SearchWorkspaceServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchWorkspace not implemented")
}
func (UnimplementedWorkspaceServiceServer) StreamWorkspace(WorkspaceService_StreamWorkspaceServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamWorkspace not implemented")
}
func (UnimplementedWorkspaceServiceServer) mustEmbedUnimplementedWorkspaceServiceServer() {}

// UnsafeWorkspaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkspaceServiceServer will
// result in compilation errors.
type UnsafeWorkspaceServiceServer interface {
	mustEmbedUnimplementedWorkspaceServiceServer()
}

func RegisterWorkspaceServiceServer(s grpc.ServiceRegistrar, srv WorkspaceServiceServer) {
	s.RegisterService(&WorkspaceService_ServiceDesc, srv)
}

func _WorkspaceService_CreateWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWorkspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceServiceServer).CreateWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.WorkspaceService/CreateWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceServiceServer).CreateWorkspace(ctx, req.(*CreateWorkspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceService_DeleteWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceServiceServer).DeleteWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.WorkspaceService/DeleteWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceServiceServer).DeleteWorkspace(ctx, req.(*DeleteWorkspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceService_SearchWorkspace_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchWorkspaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkspaceServiceServer).SearchWorkspace(m, &workspaceServiceSearchWorkspaceServer{stream})
}

type WorkspaceService_SearchWorkspaceServer interface {
	Send(*SearchWorkspaceResponse) error
	grpc.ServerStream
}

type workspaceServiceSearchWorkspaceServer struct {
	grpc.ServerStream
}

func (x *workspaceServiceSearchWorkspaceServer) Send(m *SearchWorkspaceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WorkspaceService_StreamWorkspace_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(WorkspaceServiceServer).StreamWorkspace(&workspaceServiceStreamWorkspaceServer{stream})
}

type WorkspaceService_StreamWorkspaceServer interface {
	Send(*SearchWorkspaceResponse) error
	Recv() (*SearchWorkspaceRequest, error)
	grpc.ServerStream
}

type workspaceServiceStreamWorkspaceServer struct {
	grpc.ServerStream
}

func (x *workspaceServiceStreamWorkspaceServer) Send(m *SearchWorkspaceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *workspaceServiceStreamWorkspaceServer) Recv() (*SearchWorkspaceRequest, error) {
	m := new(SearchWorkspaceRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// WorkspaceService_ServiceDesc is the grpc.ServiceDesc for WorkspaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkspaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idm.WorkspaceService",
	HandlerType: (*WorkspaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateWorkspace",
			Handler:    _WorkspaceService_CreateWorkspace_Handler,
		},
		{
			MethodName: "DeleteWorkspace",
			Handler:    _WorkspaceService_DeleteWorkspace_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchWorkspace",
			Handler:       _WorkspaceService_SearchWorkspace_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamWorkspace",
			Handler:       _WorkspaceService_StreamWorkspace_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-idm.proto",
}

// ACLServiceClient is the client API for ACLService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ACLServiceClient interface {
	// Insert a new ACL
	CreateACL(ctx context.Context, in *CreateACLRequest, opts ...grpc.CallOption) (*CreateACLResponse, error)
	// Set an expiration date that invalidates an ACL without deleting it
	ExpireACL(ctx context.Context, in *ExpireACLRequest, opts ...grpc.CallOption) (*ExpireACLResponse, error)
	// Definitely delete an ACL
	DeleteACL(ctx context.Context, in *DeleteACLRequest, opts ...grpc.CallOption) (*DeleteACLResponse, error)
	// Search ACLs by Query or Expiration period
	SearchACL(ctx context.Context, in *SearchACLRequest, opts ...grpc.CallOption) (ACLService_SearchACLClient, error)
	// Stream version of Search ACL
	StreamACL(ctx context.Context, opts ...grpc.CallOption) (ACLService_StreamACLClient, error)
	// Restore ACLs based on Query and Expiration period
	RestoreACL(ctx context.Context, in *RestoreACLRequest, opts ...grpc.CallOption) (*RestoreACLResponse, error)
}

type aCLServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewACLServiceClient(cc grpc.ClientConnInterface) ACLServiceClient {
	return &aCLServiceClient{cc}
}

func (c *aCLServiceClient) CreateACL(ctx context.Context, in *CreateACLRequest, opts ...grpc.CallOption) (*CreateACLResponse, error) {
	out := new(CreateACLResponse)
	err := c.cc.Invoke(ctx, "/idm.ACLService/CreateACL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) ExpireACL(ctx context.Context, in *ExpireACLRequest, opts ...grpc.CallOption) (*ExpireACLResponse, error) {
	out := new(ExpireACLResponse)
	err := c.cc.Invoke(ctx, "/idm.ACLService/ExpireACL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) DeleteACL(ctx context.Context, in *DeleteACLRequest, opts ...grpc.CallOption) (*DeleteACLResponse, error) {
	out := new(DeleteACLResponse)
	err := c.cc.Invoke(ctx, "/idm.ACLService/DeleteACL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aCLServiceClient) SearchACL(ctx context.Context, in *SearchACLRequest, opts ...grpc.CallOption) (ACLService_SearchACLClient, error) {
	stream, err := c.cc.NewStream(ctx, &ACLService_ServiceDesc.Streams[0], "/idm.ACLService/SearchACL", opts...)
	if err != nil {
		return nil, err
	}
	x := &aCLServiceSearchACLClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ACLService_SearchACLClient interface {
	Recv() (*SearchACLResponse, error)
	grpc.ClientStream
}

type aCLServiceSearchACLClient struct {
	grpc.ClientStream
}

func (x *aCLServiceSearchACLClient) Recv() (*SearchACLResponse, error) {
	m := new(SearchACLResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aCLServiceClient) StreamACL(ctx context.Context, opts ...grpc.CallOption) (ACLService_StreamACLClient, error) {
	stream, err := c.cc.NewStream(ctx, &ACLService_ServiceDesc.Streams[1], "/idm.ACLService/StreamACL", opts...)
	if err != nil {
		return nil, err
	}
	x := &aCLServiceStreamACLClient{stream}
	return x, nil
}

type ACLService_StreamACLClient interface {
	Send(*SearchACLRequest) error
	Recv() (*SearchACLResponse, error)
	grpc.ClientStream
}

type aCLServiceStreamACLClient struct {
	grpc.ClientStream
}

func (x *aCLServiceStreamACLClient) Send(m *SearchACLRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aCLServiceStreamACLClient) Recv() (*SearchACLResponse, error) {
	m := new(SearchACLResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aCLServiceClient) RestoreACL(ctx context.Context, in *RestoreACLRequest, opts ...grpc.CallOption) (*RestoreACLResponse, error) {
	out := new(RestoreACLResponse)
	err := c.cc.Invoke(ctx, "/idm.ACLService/RestoreACL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ACLServiceServer is the server API for ACLService service.
// All implementations must embed UnimplementedACLServiceServer
// for forward compatibility
type ACLServiceServer interface {
	// Insert a new ACL
	CreateACL(context.Context, *CreateACLRequest) (*CreateACLResponse, error)
	// Set an expiration date that invalidates an ACL without deleting it
	ExpireACL(context.Context, *ExpireACLRequest) (*ExpireACLResponse, error)
	// Definitely delete an ACL
	DeleteACL(context.Context, *DeleteACLRequest) (*DeleteACLResponse, error)
	// Search ACLs by Query or Expiration period
	SearchACL(*SearchACLRequest, ACLService_SearchACLServer) error
	// Stream version of Search ACL
	StreamACL(ACLService_StreamACLServer) error
	// Restore ACLs based on Query and Expiration period
	RestoreACL(context.Context, *RestoreACLRequest) (*RestoreACLResponse, error)
	mustEmbedUnimplementedACLServiceServer()
}

// UnimplementedACLServiceServer must be embedded to have forward compatible implementations.
type UnimplementedACLServiceServer struct {
}

func (UnimplementedACLServiceServer) CreateACL(context.Context, *CreateACLRequest) (*CreateACLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateACL not implemented")
}
func (UnimplementedACLServiceServer) ExpireACL(context.Context, *ExpireACLRequest) (*ExpireACLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExpireACL not implemented")
}
func (UnimplementedACLServiceServer) DeleteACL(context.Context, *DeleteACLRequest) (*DeleteACLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteACL not implemented")
}
func (UnimplementedACLServiceServer) SearchACL(*SearchACLRequest, ACLService_SearchACLServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchACL not implemented")
}
func (UnimplementedACLServiceServer) StreamACL(ACLService_StreamACLServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamACL not implemented")
}
func (UnimplementedACLServiceServer) RestoreACL(context.Context, *RestoreACLRequest) (*RestoreACLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreACL not implemented")
}
func (UnimplementedACLServiceServer) mustEmbedUnimplementedACLServiceServer() {}

// UnsafeACLServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ACLServiceServer will
// result in compilation errors.
type UnsafeACLServiceServer interface {
	mustEmbedUnimplementedACLServiceServer()
}

func RegisterACLServiceServer(s grpc.ServiceRegistrar, srv ACLServiceServer) {
	s.RegisterService(&ACLService_ServiceDesc, srv)
}

func _ACLService_CreateACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateACLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACLServiceServer).CreateACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.ACLService/CreateACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACLServiceServer).CreateACL(ctx, req.(*CreateACLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACLService_ExpireACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpireACLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACLServiceServer).ExpireACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.ACLService/ExpireACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACLServiceServer).ExpireACL(ctx, req.(*ExpireACLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACLService_DeleteACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteACLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACLServiceServer).DeleteACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.ACLService/DeleteACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACLServiceServer).DeleteACL(ctx, req.(*DeleteACLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ACLService_SearchACL_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchACLRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ACLServiceServer).SearchACL(m, &aCLServiceSearchACLServer{stream})
}

type ACLService_SearchACLServer interface {
	Send(*SearchACLResponse) error
	grpc.ServerStream
}

type aCLServiceSearchACLServer struct {
	grpc.ServerStream
}

func (x *aCLServiceSearchACLServer) Send(m *SearchACLResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ACLService_StreamACL_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ACLServiceServer).StreamACL(&aCLServiceStreamACLServer{stream})
}

type ACLService_StreamACLServer interface {
	Send(*SearchACLResponse) error
	Recv() (*SearchACLRequest, error)
	grpc.ServerStream
}

type aCLServiceStreamACLServer struct {
	grpc.ServerStream
}

func (x *aCLServiceStreamACLServer) Send(m *SearchACLResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aCLServiceStreamACLServer) Recv() (*SearchACLRequest, error) {
	m := new(SearchACLRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ACLService_RestoreACL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreACLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ACLServiceServer).RestoreACL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.ACLService/RestoreACL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ACLServiceServer).RestoreACL(ctx, req.(*RestoreACLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ACLService_ServiceDesc is the grpc.ServiceDesc for ACLService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ACLService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idm.ACLService",
	HandlerType: (*ACLServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateACL",
			Handler:    _ACLService_CreateACL_Handler,
		},
		{
			MethodName: "ExpireACL",
			Handler:    _ACLService_ExpireACL_Handler,
		},
		{
			MethodName: "DeleteACL",
			Handler:    _ACLService_DeleteACL_Handler,
		},
		{
			MethodName: "RestoreACL",
			Handler:    _ACLService_RestoreACL_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchACL",
			Handler:       _ACLService_SearchACL_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamACL",
			Handler:       _ACLService_StreamACL_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-idm.proto",
}

// UserMetaServiceClient is the client API for UserMetaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserMetaServiceClient interface {
	UpdateUserMeta(ctx context.Context, in *UpdateUserMetaRequest, opts ...grpc.CallOption) (*UpdateUserMetaResponse, error)
	SearchUserMeta(ctx context.Context, in *SearchUserMetaRequest, opts ...grpc.CallOption) (UserMetaService_SearchUserMetaClient, error)
	UpdateUserMetaNamespace(ctx context.Context, in *UpdateUserMetaNamespaceRequest, opts ...grpc.CallOption) (*UpdateUserMetaNamespaceResponse, error)
	ListUserMetaNamespace(ctx context.Context, in *ListUserMetaNamespaceRequest, opts ...grpc.CallOption) (UserMetaService_ListUserMetaNamespaceClient, error)
}

type userMetaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserMetaServiceClient(cc grpc.ClientConnInterface) UserMetaServiceClient {
	return &userMetaServiceClient{cc}
}

func (c *userMetaServiceClient) UpdateUserMeta(ctx context.Context, in *UpdateUserMetaRequest, opts ...grpc.CallOption) (*UpdateUserMetaResponse, error) {
	out := new(UpdateUserMetaResponse)
	err := c.cc.Invoke(ctx, "/idm.UserMetaService/UpdateUserMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMetaServiceClient) SearchUserMeta(ctx context.Context, in *SearchUserMetaRequest, opts ...grpc.CallOption) (UserMetaService_SearchUserMetaClient, error) {
	stream, err := c.cc.NewStream(ctx, &UserMetaService_ServiceDesc.Streams[0], "/idm.UserMetaService/SearchUserMeta", opts...)
	if err != nil {
		return nil, err
	}
	x := &userMetaServiceSearchUserMetaClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserMetaService_SearchUserMetaClient interface {
	Recv() (*SearchUserMetaResponse, error)
	grpc.ClientStream
}

type userMetaServiceSearchUserMetaClient struct {
	grpc.ClientStream
}

func (x *userMetaServiceSearchUserMetaClient) Recv() (*SearchUserMetaResponse, error) {
	m := new(SearchUserMetaResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userMetaServiceClient) UpdateUserMetaNamespace(ctx context.Context, in *UpdateUserMetaNamespaceRequest, opts ...grpc.CallOption) (*UpdateUserMetaNamespaceResponse, error) {
	out := new(UpdateUserMetaNamespaceResponse)
	err := c.cc.Invoke(ctx, "/idm.UserMetaService/UpdateUserMetaNamespace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMetaServiceClient) ListUserMetaNamespace(ctx context.Context, in *ListUserMetaNamespaceRequest, opts ...grpc.CallOption) (UserMetaService_ListUserMetaNamespaceClient, error) {
	stream, err := c.cc.NewStream(ctx, &UserMetaService_ServiceDesc.Streams[1], "/idm.UserMetaService/ListUserMetaNamespace", opts...)
	if err != nil {
		return nil, err
	}
	x := &userMetaServiceListUserMetaNamespaceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UserMetaService_ListUserMetaNamespaceClient interface {
	Recv() (*ListUserMetaNamespaceResponse, error)
	grpc.ClientStream
}

type userMetaServiceListUserMetaNamespaceClient struct {
	grpc.ClientStream
}

func (x *userMetaServiceListUserMetaNamespaceClient) Recv() (*ListUserMetaNamespaceResponse, error) {
	m := new(ListUserMetaNamespaceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UserMetaServiceServer is the server API for UserMetaService service.
// All implementations must embed UnimplementedUserMetaServiceServer
// for forward compatibility
type UserMetaServiceServer interface {
	UpdateUserMeta(context.Context, *UpdateUserMetaRequest) (*UpdateUserMetaResponse, error)
	SearchUserMeta(*SearchUserMetaRequest, UserMetaService_SearchUserMetaServer) error
	UpdateUserMetaNamespace(context.Context, *UpdateUserMetaNamespaceRequest) (*UpdateUserMetaNamespaceResponse, error)
	ListUserMetaNamespace(*ListUserMetaNamespaceRequest, UserMetaService_ListUserMetaNamespaceServer) error
	mustEmbedUnimplementedUserMetaServiceServer()
}

// UnimplementedUserMetaServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserMetaServiceServer struct {
}

func (UnimplementedUserMetaServiceServer) UpdateUserMeta(context.Context, *UpdateUserMetaRequest) (*UpdateUserMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserMeta not implemented")
}
func (UnimplementedUserMetaServiceServer) SearchUserMeta(*SearchUserMetaRequest, UserMetaService_SearchUserMetaServer) error {
	return status.Errorf(codes.Unimplemented, "method SearchUserMeta not implemented")
}
func (UnimplementedUserMetaServiceServer) UpdateUserMetaNamespace(context.Context, *UpdateUserMetaNamespaceRequest) (*UpdateUserMetaNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserMetaNamespace not implemented")
}
func (UnimplementedUserMetaServiceServer) ListUserMetaNamespace(*ListUserMetaNamespaceRequest, UserMetaService_ListUserMetaNamespaceServer) error {
	return status.Errorf(codes.Unimplemented, "method ListUserMetaNamespace not implemented")
}
func (UnimplementedUserMetaServiceServer) mustEmbedUnimplementedUserMetaServiceServer() {}

// UnsafeUserMetaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserMetaServiceServer will
// result in compilation errors.
type UnsafeUserMetaServiceServer interface {
	mustEmbedUnimplementedUserMetaServiceServer()
}

func RegisterUserMetaServiceServer(s grpc.ServiceRegistrar, srv UserMetaServiceServer) {
	s.RegisterService(&UserMetaService_ServiceDesc, srv)
}

func _UserMetaService_UpdateUserMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMetaServiceServer).UpdateUserMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.UserMetaService/UpdateUserMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMetaServiceServer).UpdateUserMeta(ctx, req.(*UpdateUserMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMetaService_SearchUserMeta_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchUserMetaRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserMetaServiceServer).SearchUserMeta(m, &userMetaServiceSearchUserMetaServer{stream})
}

type UserMetaService_SearchUserMetaServer interface {
	Send(*SearchUserMetaResponse) error
	grpc.ServerStream
}

type userMetaServiceSearchUserMetaServer struct {
	grpc.ServerStream
}

func (x *userMetaServiceSearchUserMetaServer) Send(m *SearchUserMetaResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UserMetaService_UpdateUserMetaNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserMetaNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMetaServiceServer).UpdateUserMetaNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.UserMetaService/UpdateUserMetaNamespace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMetaServiceServer).UpdateUserMetaNamespace(ctx, req.(*UpdateUserMetaNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMetaService_ListUserMetaNamespace_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListUserMetaNamespaceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UserMetaServiceServer).ListUserMetaNamespace(m, &userMetaServiceListUserMetaNamespaceServer{stream})
}

type UserMetaService_ListUserMetaNamespaceServer interface {
	Send(*ListUserMetaNamespaceResponse) error
	grpc.ServerStream
}

type userMetaServiceListUserMetaNamespaceServer struct {
	grpc.ServerStream
}

func (x *userMetaServiceListUserMetaNamespaceServer) Send(m *ListUserMetaNamespaceResponse) error {
	return x.ServerStream.SendMsg(m)
}

// UserMetaService_ServiceDesc is the grpc.ServiceDesc for UserMetaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserMetaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idm.UserMetaService",
	HandlerType: (*UserMetaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateUserMeta",
			Handler:    _UserMetaService_UpdateUserMeta_Handler,
		},
		{
			MethodName: "UpdateUserMetaNamespace",
			Handler:    _UserMetaService_UpdateUserMetaNamespace_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SearchUserMeta",
			Handler:       _UserMetaService_SearchUserMeta_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListUserMetaNamespace",
			Handler:       _UserMetaService_ListUserMetaNamespace_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-idm.proto",
}

// PolicyEngineServiceClient is the client API for PolicyEngineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PolicyEngineServiceClient interface {
	IsAllowed(ctx context.Context, in *PolicyEngineRequest, opts ...grpc.CallOption) (*PolicyEngineResponse, error)
	StorePolicyGroup(ctx context.Context, in *StorePolicyGroupRequest, opts ...grpc.CallOption) (*StorePolicyGroupResponse, error)
	ListPolicyGroups(ctx context.Context, in *ListPolicyGroupsRequest, opts ...grpc.CallOption) (*ListPolicyGroupsResponse, error)
	StreamPolicyGroups(ctx context.Context, in *ListPolicyGroupsRequest, opts ...grpc.CallOption) (PolicyEngineService_StreamPolicyGroupsClient, error)
	DeletePolicyGroup(ctx context.Context, in *DeletePolicyGroupRequest, opts ...grpc.CallOption) (*DeletePolicyGroupResponse, error)
}

type policyEngineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPolicyEngineServiceClient(cc grpc.ClientConnInterface) PolicyEngineServiceClient {
	return &policyEngineServiceClient{cc}
}

func (c *policyEngineServiceClient) IsAllowed(ctx context.Context, in *PolicyEngineRequest, opts ...grpc.CallOption) (*PolicyEngineResponse, error) {
	out := new(PolicyEngineResponse)
	err := c.cc.Invoke(ctx, "/idm.PolicyEngineService/IsAllowed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyEngineServiceClient) StorePolicyGroup(ctx context.Context, in *StorePolicyGroupRequest, opts ...grpc.CallOption) (*StorePolicyGroupResponse, error) {
	out := new(StorePolicyGroupResponse)
	err := c.cc.Invoke(ctx, "/idm.PolicyEngineService/StorePolicyGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyEngineServiceClient) ListPolicyGroups(ctx context.Context, in *ListPolicyGroupsRequest, opts ...grpc.CallOption) (*ListPolicyGroupsResponse, error) {
	out := new(ListPolicyGroupsResponse)
	err := c.cc.Invoke(ctx, "/idm.PolicyEngineService/ListPolicyGroups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyEngineServiceClient) StreamPolicyGroups(ctx context.Context, in *ListPolicyGroupsRequest, opts ...grpc.CallOption) (PolicyEngineService_StreamPolicyGroupsClient, error) {
	stream, err := c.cc.NewStream(ctx, &PolicyEngineService_ServiceDesc.Streams[0], "/idm.PolicyEngineService/StreamPolicyGroups", opts...)
	if err != nil {
		return nil, err
	}
	x := &policyEngineServiceStreamPolicyGroupsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PolicyEngineService_StreamPolicyGroupsClient interface {
	Recv() (*PolicyGroup, error)
	grpc.ClientStream
}

type policyEngineServiceStreamPolicyGroupsClient struct {
	grpc.ClientStream
}

func (x *policyEngineServiceStreamPolicyGroupsClient) Recv() (*PolicyGroup, error) {
	m := new(PolicyGroup)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *policyEngineServiceClient) DeletePolicyGroup(ctx context.Context, in *DeletePolicyGroupRequest, opts ...grpc.CallOption) (*DeletePolicyGroupResponse, error) {
	out := new(DeletePolicyGroupResponse)
	err := c.cc.Invoke(ctx, "/idm.PolicyEngineService/DeletePolicyGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicyEngineServiceServer is the server API for PolicyEngineService service.
// All implementations must embed UnimplementedPolicyEngineServiceServer
// for forward compatibility
type PolicyEngineServiceServer interface {
	IsAllowed(context.Context, *PolicyEngineRequest) (*PolicyEngineResponse, error)
	StorePolicyGroup(context.Context, *StorePolicyGroupRequest) (*StorePolicyGroupResponse, error)
	ListPolicyGroups(context.Context, *ListPolicyGroupsRequest) (*ListPolicyGroupsResponse, error)
	StreamPolicyGroups(*ListPolicyGroupsRequest, PolicyEngineService_StreamPolicyGroupsServer) error
	DeletePolicyGroup(context.Context, *DeletePolicyGroupRequest) (*DeletePolicyGroupResponse, error)
	mustEmbedUnimplementedPolicyEngineServiceServer()
}

// UnimplementedPolicyEngineServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPolicyEngineServiceServer struct {
}

func (UnimplementedPolicyEngineServiceServer) IsAllowed(context.Context, *PolicyEngineRequest) (*PolicyEngineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAllowed not implemented")
}
func (UnimplementedPolicyEngineServiceServer) StorePolicyGroup(context.Context, *StorePolicyGroupRequest) (*StorePolicyGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StorePolicyGroup not implemented")
}
func (UnimplementedPolicyEngineServiceServer) ListPolicyGroups(context.Context, *ListPolicyGroupsRequest) (*ListPolicyGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPolicyGroups not implemented")
}
func (UnimplementedPolicyEngineServiceServer) StreamPolicyGroups(*ListPolicyGroupsRequest, PolicyEngineService_StreamPolicyGroupsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamPolicyGroups not implemented")
}
func (UnimplementedPolicyEngineServiceServer) DeletePolicyGroup(context.Context, *DeletePolicyGroupRequest) (*DeletePolicyGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePolicyGroup not implemented")
}
func (UnimplementedPolicyEngineServiceServer) mustEmbedUnimplementedPolicyEngineServiceServer() {}

// UnsafePolicyEngineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PolicyEngineServiceServer will
// result in compilation errors.
type UnsafePolicyEngineServiceServer interface {
	mustEmbedUnimplementedPolicyEngineServiceServer()
}

func RegisterPolicyEngineServiceServer(s grpc.ServiceRegistrar, srv PolicyEngineServiceServer) {
	s.RegisterService(&PolicyEngineService_ServiceDesc, srv)
}

func _PolicyEngineService_IsAllowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyEngineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyEngineServiceServer).IsAllowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.PolicyEngineService/IsAllowed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyEngineServiceServer).IsAllowed(ctx, req.(*PolicyEngineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyEngineService_StorePolicyGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorePolicyGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyEngineServiceServer).StorePolicyGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.PolicyEngineService/StorePolicyGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyEngineServiceServer).StorePolicyGroup(ctx, req.(*StorePolicyGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyEngineService_ListPolicyGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPolicyGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyEngineServiceServer).ListPolicyGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.PolicyEngineService/ListPolicyGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyEngineServiceServer).ListPolicyGroups(ctx, req.(*ListPolicyGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyEngineService_StreamPolicyGroups_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPolicyGroupsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PolicyEngineServiceServer).StreamPolicyGroups(m, &policyEngineServiceStreamPolicyGroupsServer{stream})
}

type PolicyEngineService_StreamPolicyGroupsServer interface {
	Send(*PolicyGroup) error
	grpc.ServerStream
}

type policyEngineServiceStreamPolicyGroupsServer struct {
	grpc.ServerStream
}

func (x *policyEngineServiceStreamPolicyGroupsServer) Send(m *PolicyGroup) error {
	return x.ServerStream.SendMsg(m)
}

func _PolicyEngineService_DeletePolicyGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePolicyGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyEngineServiceServer).DeletePolicyGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/idm.PolicyEngineService/DeletePolicyGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyEngineServiceServer).DeletePolicyGroup(ctx, req.(*DeletePolicyGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PolicyEngineService_ServiceDesc is the grpc.ServiceDesc for PolicyEngineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PolicyEngineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "idm.PolicyEngineService",
	HandlerType: (*PolicyEngineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IsAllowed",
			Handler:    _PolicyEngineService_IsAllowed_Handler,
		},
		{
			MethodName: "StorePolicyGroup",
			Handler:    _PolicyEngineService_StorePolicyGroup_Handler,
		},
		{
			MethodName: "ListPolicyGroups",
			Handler:    _PolicyEngineService_ListPolicyGroups_Handler,
		},
		{
			MethodName: "DeletePolicyGroup",
			Handler:    _PolicyEngineService_DeletePolicyGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPolicyGroups",
			Handler:       _PolicyEngineService_StreamPolicyGroups_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-idm.proto",
}
