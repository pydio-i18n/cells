// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-client-stub v1.1.0
// - protoc             (unknown)
// source: cells-encryption.proto

package encryption

import (
	context "context"
	fmt "fmt"
	stubs "github.com/pydio/cells/v4/common/server/stubs"
	grpc "google.golang.org/grpc"
	io "io"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

type UserKeyStoreStub struct {
	UserKeyStoreServer
}

func (s *UserKeyStoreStub) Invoke(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error {
	fmt.Println("Serving", method, args, reply, opts)
	var e error
	switch method {
	case "/encryption.UserKeyStore/AddKey":
		resp, er := s.UserKeyStoreServer.AddKey(ctx, args.(*AddKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.UserKeyStore/GetKey":
		resp, er := s.UserKeyStoreServer.GetKey(ctx, args.(*GetKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.UserKeyStore/AdminListKeys":
		resp, er := s.UserKeyStoreServer.AdminListKeys(ctx, args.(*AdminListKeysRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.UserKeyStore/AdminCreateKey":
		resp, er := s.UserKeyStoreServer.AdminCreateKey(ctx, args.(*AdminCreateKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.UserKeyStore/AdminDeleteKey":
		resp, er := s.UserKeyStoreServer.AdminDeleteKey(ctx, args.(*AdminDeleteKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.UserKeyStore/AdminExportKey":
		resp, er := s.UserKeyStoreServer.AdminExportKey(ctx, args.(*AdminExportKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.UserKeyStore/AdminImportKey":
		resp, er := s.UserKeyStoreServer.AdminImportKey(ctx, args.(*AdminImportKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	default:
		e = fmt.Errorf(method + " not implemented")
	}
	return e
}
func (s *UserKeyStoreStub) NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) {
	fmt.Println("Serving", method)
	switch method {
	}
	return nil, fmt.Errorf(method + "  not implemented")
}

type NodeKeyManagerStub struct {
	NodeKeyManagerServer
}

func (s *NodeKeyManagerStub) Invoke(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error {
	fmt.Println("Serving", method, args, reply, opts)
	var e error
	switch method {
	case "/encryption.NodeKeyManager/GetNodeInfo":
		resp, er := s.NodeKeyManagerServer.GetNodeInfo(ctx, args.(*GetNodeInfoRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.NodeKeyManager/GetNodePlainSize":
		resp, er := s.NodeKeyManagerServer.GetNodePlainSize(ctx, args.(*GetNodePlainSizeRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.NodeKeyManager/CopyNodeInfo":
		resp, er := s.NodeKeyManagerServer.CopyNodeInfo(ctx, args.(*CopyNodeInfoRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.NodeKeyManager/DeleteNode":
		resp, er := s.NodeKeyManagerServer.DeleteNode(ctx, args.(*DeleteNodeRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.NodeKeyManager/DeleteNodeKey":
		resp, er := s.NodeKeyManagerServer.DeleteNodeKey(ctx, args.(*DeleteNodeKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/encryption.NodeKeyManager/DeleteNodeSharedKey":
		resp, er := s.NodeKeyManagerServer.DeleteNodeSharedKey(ctx, args.(*DeleteNodeSharedKeyRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	default:
		e = fmt.Errorf(method + " not implemented")
	}
	return e
}
func (s *NodeKeyManagerStub) NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) {
	fmt.Println("Serving", method)
	switch method {
	case "/encryption.NodeKeyManager/SetNodeInfo":
		st := &NodeKeyManagerStub_SetNodeInfoStreamer{}
		st.Init(ctx)
		go s.NodeKeyManagerServer.SetNodeInfo(st)
		return st, nil
	}
	return nil, fmt.Errorf(method + "  not implemented")
}

type NodeKeyManagerStub_SetNodeInfoStreamer struct {
	stubs.BidirServerStreamerCore
}

func (s *NodeKeyManagerStub_SetNodeInfoStreamer) Recv() (*SetNodeInfoRequest, error) {
	if req, o := <-s.ReqChan; o {
		return req.(*SetNodeInfoRequest), nil
	} else {
		return nil, io.EOF
	}
}
func (s *NodeKeyManagerStub_SetNodeInfoStreamer) Send(response *SetNodeInfoResponse) error {
	s.RespChan <- response
	return nil
}
func (s *NodeKeyManagerStub_SetNodeInfoStreamer) SendAndClose(*SetNodeInfoResponse) error {
	return nil
}
