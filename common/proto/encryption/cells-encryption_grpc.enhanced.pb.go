// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-encryption.proto

package encryption

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedUserKeyStoreServers     = make(map[string]UserKeyStoreEnhancedServer)
	enhancedUserKeyStoreServersLock = sync.RWMutex{}
)

type NamedUserKeyStoreServer interface {
	UserKeyStoreServer
	Name() string
}
type UserKeyStoreEnhancedServer map[string]NamedUserKeyStoreServer

func (m UserKeyStoreEnhancedServer) AddKey(ctx context.Context, r *AddKeyRequest) (*AddKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AddKey should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AddKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AddKey not implemented")
}

func (m UserKeyStoreEnhancedServer) GetKey(ctx context.Context, r *GetKeyRequest) (*GetKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetKey should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}

func (m UserKeyStoreEnhancedServer) AdminListKeys(ctx context.Context, r *AdminListKeysRequest) (*AdminListKeysResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AdminListKeys should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AdminListKeys(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AdminListKeys not implemented")
}

func (m UserKeyStoreEnhancedServer) AdminCreateKey(ctx context.Context, r *AdminCreateKeyRequest) (*AdminCreateKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AdminCreateKey should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AdminCreateKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AdminCreateKey not implemented")
}

func (m UserKeyStoreEnhancedServer) AdminDeleteKey(ctx context.Context, r *AdminDeleteKeyRequest) (*AdminDeleteKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AdminDeleteKey should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AdminDeleteKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AdminDeleteKey not implemented")
}

func (m UserKeyStoreEnhancedServer) AdminExportKey(ctx context.Context, r *AdminExportKeyRequest) (*AdminExportKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AdminExportKey should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AdminExportKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AdminExportKey not implemented")
}

func (m UserKeyStoreEnhancedServer) AdminImportKey(ctx context.Context, r *AdminImportKeyRequest) (*AdminImportKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AdminImportKey should have a context")
	}
	enhancedUserKeyStoreServersLock.RLock()
	defer enhancedUserKeyStoreServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AdminImportKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AdminImportKey not implemented")
}
func (m UserKeyStoreEnhancedServer) mustEmbedUnimplementedUserKeyStoreServer() {}
func RegisterUserKeyStoreEnhancedServer(s grpc.ServiceRegistrar, srv NamedUserKeyStoreServer) {
	enhancedUserKeyStoreServersLock.Lock()
	defer enhancedUserKeyStoreServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedUserKeyStoreServers[addr]
	if !ok {
		m = UserKeyStoreEnhancedServer{}
		enhancedUserKeyStoreServers[addr] = m
		RegisterUserKeyStoreServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterUserKeyStoreEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedUserKeyStoreServersLock.Lock()
	defer enhancedUserKeyStoreServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedUserKeyStoreServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedNodeKeyManagerServers     = make(map[string]NodeKeyManagerEnhancedServer)
	enhancedNodeKeyManagerServersLock = sync.RWMutex{}
)

type NamedNodeKeyManagerServer interface {
	NodeKeyManagerServer
	Name() string
}
type NodeKeyManagerEnhancedServer map[string]NamedNodeKeyManagerServer

func (m NodeKeyManagerEnhancedServer) GetNodeInfo(ctx context.Context, r *GetNodeInfoRequest) (*GetNodeInfoResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetNodeInfo should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetNodeInfo(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}

func (m NodeKeyManagerEnhancedServer) GetNodePlainSize(ctx context.Context, r *GetNodePlainSizeRequest) (*GetNodePlainSizeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetNodePlainSize should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetNodePlainSize(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetNodePlainSize not implemented")
}

func (m NodeKeyManagerEnhancedServer) SetNodeInfo(s NodeKeyManager_SetNodeInfoServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method SetNodeInfo should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.SetNodeInfo(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method SetNodeInfo not implemented")
}

func (m NodeKeyManagerEnhancedServer) CopyNodeInfo(ctx context.Context, r *CopyNodeInfoRequest) (*CopyNodeInfoResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method CopyNodeInfo should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.CopyNodeInfo(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CopyNodeInfo not implemented")
}

func (m NodeKeyManagerEnhancedServer) DeleteNode(ctx context.Context, r *DeleteNodeRequest) (*DeleteNodeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteNode should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteNode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}

func (m NodeKeyManagerEnhancedServer) DeleteNodeKey(ctx context.Context, r *DeleteNodeKeyRequest) (*DeleteNodeKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteNodeKey should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteNodeKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodeKey not implemented")
}

func (m NodeKeyManagerEnhancedServer) DeleteNodeSharedKey(ctx context.Context, r *DeleteNodeSharedKeyRequest) (*DeleteNodeSharedKeyResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeleteNodeSharedKey should have a context")
	}
	enhancedNodeKeyManagerServersLock.RLock()
	defer enhancedNodeKeyManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeleteNodeSharedKey(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodeSharedKey not implemented")
}
func (m NodeKeyManagerEnhancedServer) mustEmbedUnimplementedNodeKeyManagerServer() {}
func RegisterNodeKeyManagerEnhancedServer(s grpc.ServiceRegistrar, srv NamedNodeKeyManagerServer) {
	enhancedNodeKeyManagerServersLock.Lock()
	defer enhancedNodeKeyManagerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedNodeKeyManagerServers[addr]
	if !ok {
		m = NodeKeyManagerEnhancedServer{}
		enhancedNodeKeyManagerServers[addr] = m
		RegisterNodeKeyManagerServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterNodeKeyManagerEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedNodeKeyManagerServersLock.Lock()
	defer enhancedNodeKeyManagerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedNodeKeyManagerServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
