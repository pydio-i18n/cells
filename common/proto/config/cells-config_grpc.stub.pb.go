// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-client-stub v1.1.0
// - protoc             (unknown)
// source: cells-config.proto

package config

import (
	context "context"
	fmt "fmt"
	stubs "github.com/pydio/cells/v5/common/server/stubs"
	grpc "google.golang.org/grpc"
	io "io"
	time "time"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

type ConfigStub struct {
	ConfigServer
}

func (s *ConfigStub) Invoke(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error {
	fmt.Println("Serving", method, args, reply, opts)
	var e error
	switch method {
	case "/config.Config/Get":
		resp, er := s.ConfigServer.Get(ctx, args.(*GetRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/config.Config/Set":
		resp, er := s.ConfigServer.Set(ctx, args.(*SetRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/config.Config/Delete":
		resp, er := s.ConfigServer.Delete(ctx, args.(*DeleteRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	case "/config.Config/Save":
		resp, er := s.ConfigServer.Save(ctx, args.(*SaveRequest))
		if er == nil {
			e = stubs.AssignToInterface(resp, reply)
		} else {
			e = er
		}
	default:
		e = fmt.Errorf(method + " not implemented")
	}
	return e
}
func (s *ConfigStub) NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error) {
	fmt.Println("Serving", method)
	switch method {
	case "/config.Config/Watch":
		st := &ConfigStub_WatchStreamer{}
		st.Init(ctx, func(i interface{}) error {
			var e error
			go func() {
				defer func() {
					close(st.RespChan)
				}()
				e = s.ConfigServer.Watch(i.(*WatchRequest), st)
			}()
			<-time.After(100 * time.Millisecond)
			return e
		})
		return st, nil
	case "/config.Config/NewLocker":
		st := &ConfigStub_NewLockerStreamer{}
		st.Init(ctx)
		go s.ConfigServer.NewLocker(st)
		return st, nil
	}
	return nil, fmt.Errorf(method + "  not implemented")
}

type ConfigStub_WatchStreamer struct {
	stubs.ClientServerStreamerCore
}

func (s *ConfigStub_WatchStreamer) Send(response *WatchResponse) error {
	s.RespChan <- response
	return nil
}

type ConfigStub_NewLockerStreamer struct {
	stubs.BidirServerStreamerCore
}

func (s *ConfigStub_NewLockerStreamer) Recv() (*NewLockerRequest, error) {
	if req, o := <-s.ReqChan; o {
		return req.(*NewLockerRequest), nil
	} else {
		return nil, io.EOF
	}
}
func (s *ConfigStub_NewLockerStreamer) Send(response *NewLockerResponse) error {
	s.RespChan <- response
	return nil
}
func (s *ConfigStub_NewLockerStreamer) SendAndClose(*NewLockerResponse) error {
	return nil
}
