// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package auth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthTokenRevokerClient is the client API for AuthTokenRevoker service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthTokenRevokerClient interface {
	// Revoker invalidates the current token and specifies if the invalidation is due to a refresh or a revokation
	Revoke(ctx context.Context, in *RevokeTokenRequest, opts ...grpc.CallOption) (*RevokeTokenResponse, error)
}

type authTokenRevokerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthTokenRevokerClient(cc grpc.ClientConnInterface) AuthTokenRevokerClient {
	return &authTokenRevokerClient{cc}
}

func (c *authTokenRevokerClient) Revoke(ctx context.Context, in *RevokeTokenRequest, opts ...grpc.CallOption) (*RevokeTokenResponse, error) {
	out := new(RevokeTokenResponse)
	err := c.cc.Invoke(ctx, "/auth.AuthTokenRevoker/Revoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthTokenRevokerServer is the server API for AuthTokenRevoker service.
// All implementations must embed UnimplementedAuthTokenRevokerServer
// for forward compatibility
type AuthTokenRevokerServer interface {
	// Revoker invalidates the current token and specifies if the invalidation is due to a refresh or a revokation
	Revoke(context.Context, *RevokeTokenRequest) (*RevokeTokenResponse, error)
	mustEmbedUnimplementedAuthTokenRevokerServer()
}

// UnimplementedAuthTokenRevokerServer must be embedded to have forward compatible implementations.
type UnimplementedAuthTokenRevokerServer struct {
}

func (UnimplementedAuthTokenRevokerServer) Revoke(context.Context, *RevokeTokenRequest) (*RevokeTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (UnimplementedAuthTokenRevokerServer) mustEmbedUnimplementedAuthTokenRevokerServer() {}

// UnsafeAuthTokenRevokerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthTokenRevokerServer will
// result in compilation errors.
type UnsafeAuthTokenRevokerServer interface {
	mustEmbedUnimplementedAuthTokenRevokerServer()
}

func RegisterAuthTokenRevokerServer(s grpc.ServiceRegistrar, srv AuthTokenRevokerServer) {
	s.RegisterService(&AuthTokenRevoker_ServiceDesc, srv)
}

func _AuthTokenRevoker_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthTokenRevokerServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthTokenRevoker/Revoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthTokenRevokerServer).Revoke(ctx, req.(*RevokeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthTokenRevoker_ServiceDesc is the grpc.ServiceDesc for AuthTokenRevoker service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthTokenRevoker_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthTokenRevoker",
	HandlerType: (*AuthTokenRevokerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Revoke",
			Handler:    _AuthTokenRevoker_Revoke_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// AuthTokenPrunerClient is the client API for AuthTokenPruner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthTokenPrunerClient interface {
	// PruneTokens clear revoked tokens
	PruneTokens(ctx context.Context, in *PruneTokensRequest, opts ...grpc.CallOption) (*PruneTokensResponse, error)
}

type authTokenPrunerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthTokenPrunerClient(cc grpc.ClientConnInterface) AuthTokenPrunerClient {
	return &authTokenPrunerClient{cc}
}

func (c *authTokenPrunerClient) PruneTokens(ctx context.Context, in *PruneTokensRequest, opts ...grpc.CallOption) (*PruneTokensResponse, error) {
	out := new(PruneTokensResponse)
	err := c.cc.Invoke(ctx, "/auth.AuthTokenPruner/PruneTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthTokenPrunerServer is the server API for AuthTokenPruner service.
// All implementations must embed UnimplementedAuthTokenPrunerServer
// for forward compatibility
type AuthTokenPrunerServer interface {
	// PruneTokens clear revoked tokens
	PruneTokens(context.Context, *PruneTokensRequest) (*PruneTokensResponse, error)
	mustEmbedUnimplementedAuthTokenPrunerServer()
}

// UnimplementedAuthTokenPrunerServer must be embedded to have forward compatible implementations.
type UnimplementedAuthTokenPrunerServer struct {
}

func (UnimplementedAuthTokenPrunerServer) PruneTokens(context.Context, *PruneTokensRequest) (*PruneTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PruneTokens not implemented")
}
func (UnimplementedAuthTokenPrunerServer) mustEmbedUnimplementedAuthTokenPrunerServer() {}

// UnsafeAuthTokenPrunerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthTokenPrunerServer will
// result in compilation errors.
type UnsafeAuthTokenPrunerServer interface {
	mustEmbedUnimplementedAuthTokenPrunerServer()
}

func RegisterAuthTokenPrunerServer(s grpc.ServiceRegistrar, srv AuthTokenPrunerServer) {
	s.RegisterService(&AuthTokenPruner_ServiceDesc, srv)
}

func _AuthTokenPruner_PruneTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PruneTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthTokenPrunerServer).PruneTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthTokenPruner/PruneTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthTokenPrunerServer).PruneTokens(ctx, req.(*PruneTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthTokenPruner_ServiceDesc is the grpc.ServiceDesc for AuthTokenPruner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthTokenPruner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthTokenPruner",
	HandlerType: (*AuthTokenPrunerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PruneTokens",
			Handler:    _AuthTokenPruner_PruneTokens_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// LoginProviderClient is the client API for LoginProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoginProviderClient interface {
	GetLogin(ctx context.Context, in *GetLoginRequest, opts ...grpc.CallOption) (*GetLoginResponse, error)
	CreateLogin(ctx context.Context, in *CreateLoginRequest, opts ...grpc.CallOption) (*CreateLoginResponse, error)
	AcceptLogin(ctx context.Context, in *AcceptLoginRequest, opts ...grpc.CallOption) (*AcceptLoginResponse, error)
}

type loginProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewLoginProviderClient(cc grpc.ClientConnInterface) LoginProviderClient {
	return &loginProviderClient{cc}
}

func (c *loginProviderClient) GetLogin(ctx context.Context, in *GetLoginRequest, opts ...grpc.CallOption) (*GetLoginResponse, error) {
	out := new(GetLoginResponse)
	err := c.cc.Invoke(ctx, "/auth.LoginProvider/GetLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginProviderClient) CreateLogin(ctx context.Context, in *CreateLoginRequest, opts ...grpc.CallOption) (*CreateLoginResponse, error) {
	out := new(CreateLoginResponse)
	err := c.cc.Invoke(ctx, "/auth.LoginProvider/CreateLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginProviderClient) AcceptLogin(ctx context.Context, in *AcceptLoginRequest, opts ...grpc.CallOption) (*AcceptLoginResponse, error) {
	out := new(AcceptLoginResponse)
	err := c.cc.Invoke(ctx, "/auth.LoginProvider/AcceptLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoginProviderServer is the server API for LoginProvider service.
// All implementations must embed UnimplementedLoginProviderServer
// for forward compatibility
type LoginProviderServer interface {
	GetLogin(context.Context, *GetLoginRequest) (*GetLoginResponse, error)
	CreateLogin(context.Context, *CreateLoginRequest) (*CreateLoginResponse, error)
	AcceptLogin(context.Context, *AcceptLoginRequest) (*AcceptLoginResponse, error)
	mustEmbedUnimplementedLoginProviderServer()
}

// UnimplementedLoginProviderServer must be embedded to have forward compatible implementations.
type UnimplementedLoginProviderServer struct {
}

func (UnimplementedLoginProviderServer) GetLogin(context.Context, *GetLoginRequest) (*GetLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogin not implemented")
}
func (UnimplementedLoginProviderServer) CreateLogin(context.Context, *CreateLoginRequest) (*CreateLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogin not implemented")
}
func (UnimplementedLoginProviderServer) AcceptLogin(context.Context, *AcceptLoginRequest) (*AcceptLoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogin not implemented")
}
func (UnimplementedLoginProviderServer) mustEmbedUnimplementedLoginProviderServer() {}

// UnsafeLoginProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoginProviderServer will
// result in compilation errors.
type UnsafeLoginProviderServer interface {
	mustEmbedUnimplementedLoginProviderServer()
}

func RegisterLoginProviderServer(s grpc.ServiceRegistrar, srv LoginProviderServer) {
	s.RegisterService(&LoginProvider_ServiceDesc, srv)
}

func _LoginProvider_GetLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginProviderServer).GetLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.LoginProvider/GetLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginProviderServer).GetLogin(ctx, req.(*GetLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginProvider_CreateLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginProviderServer).CreateLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.LoginProvider/CreateLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginProviderServer).CreateLogin(ctx, req.(*CreateLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginProvider_AcceptLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginProviderServer).AcceptLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.LoginProvider/AcceptLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginProviderServer).AcceptLogin(ctx, req.(*AcceptLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LoginProvider_ServiceDesc is the grpc.ServiceDesc for LoginProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoginProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.LoginProvider",
	HandlerType: (*LoginProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLogin",
			Handler:    _LoginProvider_GetLogin_Handler,
		},
		{
			MethodName: "CreateLogin",
			Handler:    _LoginProvider_CreateLogin_Handler,
		},
		{
			MethodName: "AcceptLogin",
			Handler:    _LoginProvider_AcceptLogin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// ConsentProviderClient is the client API for ConsentProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsentProviderClient interface {
	GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error)
	CreateConsent(ctx context.Context, in *CreateConsentRequest, opts ...grpc.CallOption) (*CreateConsentResponse, error)
	AcceptConsent(ctx context.Context, in *AcceptConsentRequest, opts ...grpc.CallOption) (*AcceptConsentResponse, error)
}

type consentProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewConsentProviderClient(cc grpc.ClientConnInterface) ConsentProviderClient {
	return &consentProviderClient{cc}
}

func (c *consentProviderClient) GetConsent(ctx context.Context, in *GetConsentRequest, opts ...grpc.CallOption) (*GetConsentResponse, error) {
	out := new(GetConsentResponse)
	err := c.cc.Invoke(ctx, "/auth.ConsentProvider/GetConsent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentProviderClient) CreateConsent(ctx context.Context, in *CreateConsentRequest, opts ...grpc.CallOption) (*CreateConsentResponse, error) {
	out := new(CreateConsentResponse)
	err := c.cc.Invoke(ctx, "/auth.ConsentProvider/CreateConsent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consentProviderClient) AcceptConsent(ctx context.Context, in *AcceptConsentRequest, opts ...grpc.CallOption) (*AcceptConsentResponse, error) {
	out := new(AcceptConsentResponse)
	err := c.cc.Invoke(ctx, "/auth.ConsentProvider/AcceptConsent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsentProviderServer is the server API for ConsentProvider service.
// All implementations must embed UnimplementedConsentProviderServer
// for forward compatibility
type ConsentProviderServer interface {
	GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error)
	CreateConsent(context.Context, *CreateConsentRequest) (*CreateConsentResponse, error)
	AcceptConsent(context.Context, *AcceptConsentRequest) (*AcceptConsentResponse, error)
	mustEmbedUnimplementedConsentProviderServer()
}

// UnimplementedConsentProviderServer must be embedded to have forward compatible implementations.
type UnimplementedConsentProviderServer struct {
}

func (UnimplementedConsentProviderServer) GetConsent(context.Context, *GetConsentRequest) (*GetConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}
func (UnimplementedConsentProviderServer) CreateConsent(context.Context, *CreateConsentRequest) (*CreateConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConsent not implemented")
}
func (UnimplementedConsentProviderServer) AcceptConsent(context.Context, *AcceptConsentRequest) (*AcceptConsentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptConsent not implemented")
}
func (UnimplementedConsentProviderServer) mustEmbedUnimplementedConsentProviderServer() {}

// UnsafeConsentProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsentProviderServer will
// result in compilation errors.
type UnsafeConsentProviderServer interface {
	mustEmbedUnimplementedConsentProviderServer()
}

func RegisterConsentProviderServer(s grpc.ServiceRegistrar, srv ConsentProviderServer) {
	s.RegisterService(&ConsentProvider_ServiceDesc, srv)
}

func _ConsentProvider_GetConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentProviderServer).GetConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.ConsentProvider/GetConsent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentProviderServer).GetConsent(ctx, req.(*GetConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsentProvider_CreateConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentProviderServer).CreateConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.ConsentProvider/CreateConsent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentProviderServer).CreateConsent(ctx, req.(*CreateConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsentProvider_AcceptConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsentProviderServer).AcceptConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.ConsentProvider/AcceptConsent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsentProviderServer).AcceptConsent(ctx, req.(*AcceptConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConsentProvider_ServiceDesc is the grpc.ServiceDesc for ConsentProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConsentProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.ConsentProvider",
	HandlerType: (*ConsentProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConsent",
			Handler:    _ConsentProvider_GetConsent_Handler,
		},
		{
			MethodName: "CreateConsent",
			Handler:    _ConsentProvider_CreateConsent_Handler,
		},
		{
			MethodName: "AcceptConsent",
			Handler:    _ConsentProvider_AcceptConsent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// LogoutProviderClient is the client API for LogoutProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogoutProviderClient interface {
	CreateLogout(ctx context.Context, in *CreateLogoutRequest, opts ...grpc.CallOption) (*CreateLogoutResponse, error)
	AcceptLogout(ctx context.Context, in *AcceptLogoutRequest, opts ...grpc.CallOption) (*AcceptLogoutResponse, error)
}

type logoutProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewLogoutProviderClient(cc grpc.ClientConnInterface) LogoutProviderClient {
	return &logoutProviderClient{cc}
}

func (c *logoutProviderClient) CreateLogout(ctx context.Context, in *CreateLogoutRequest, opts ...grpc.CallOption) (*CreateLogoutResponse, error) {
	out := new(CreateLogoutResponse)
	err := c.cc.Invoke(ctx, "/auth.LogoutProvider/CreateLogout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logoutProviderClient) AcceptLogout(ctx context.Context, in *AcceptLogoutRequest, opts ...grpc.CallOption) (*AcceptLogoutResponse, error) {
	out := new(AcceptLogoutResponse)
	err := c.cc.Invoke(ctx, "/auth.LogoutProvider/AcceptLogout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogoutProviderServer is the server API for LogoutProvider service.
// All implementations must embed UnimplementedLogoutProviderServer
// for forward compatibility
type LogoutProviderServer interface {
	CreateLogout(context.Context, *CreateLogoutRequest) (*CreateLogoutResponse, error)
	AcceptLogout(context.Context, *AcceptLogoutRequest) (*AcceptLogoutResponse, error)
	mustEmbedUnimplementedLogoutProviderServer()
}

// UnimplementedLogoutProviderServer must be embedded to have forward compatible implementations.
type UnimplementedLogoutProviderServer struct {
}

func (UnimplementedLogoutProviderServer) CreateLogout(context.Context, *CreateLogoutRequest) (*CreateLogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogout not implemented")
}
func (UnimplementedLogoutProviderServer) AcceptLogout(context.Context, *AcceptLogoutRequest) (*AcceptLogoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogout not implemented")
}
func (UnimplementedLogoutProviderServer) mustEmbedUnimplementedLogoutProviderServer() {}

// UnsafeLogoutProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogoutProviderServer will
// result in compilation errors.
type UnsafeLogoutProviderServer interface {
	mustEmbedUnimplementedLogoutProviderServer()
}

func RegisterLogoutProviderServer(s grpc.ServiceRegistrar, srv LogoutProviderServer) {
	s.RegisterService(&LogoutProvider_ServiceDesc, srv)
}

func _LogoutProvider_CreateLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogoutProviderServer).CreateLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.LogoutProvider/CreateLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogoutProviderServer).CreateLogout(ctx, req.(*CreateLogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LogoutProvider_AcceptLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptLogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogoutProviderServer).AcceptLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.LogoutProvider/AcceptLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogoutProviderServer).AcceptLogout(ctx, req.(*AcceptLogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LogoutProvider_ServiceDesc is the grpc.ServiceDesc for LogoutProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogoutProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.LogoutProvider",
	HandlerType: (*LogoutProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLogout",
			Handler:    _LogoutProvider_CreateLogout_Handler,
		},
		{
			MethodName: "AcceptLogout",
			Handler:    _LogoutProvider_AcceptLogout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// AuthCodeProviderClient is the client API for AuthCodeProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthCodeProviderClient interface {
	CreateAuthCode(ctx context.Context, in *CreateAuthCodeRequest, opts ...grpc.CallOption) (*CreateAuthCodeResponse, error)
}

type authCodeProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthCodeProviderClient(cc grpc.ClientConnInterface) AuthCodeProviderClient {
	return &authCodeProviderClient{cc}
}

func (c *authCodeProviderClient) CreateAuthCode(ctx context.Context, in *CreateAuthCodeRequest, opts ...grpc.CallOption) (*CreateAuthCodeResponse, error) {
	out := new(CreateAuthCodeResponse)
	err := c.cc.Invoke(ctx, "/auth.AuthCodeProvider/CreateAuthCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthCodeProviderServer is the server API for AuthCodeProvider service.
// All implementations must embed UnimplementedAuthCodeProviderServer
// for forward compatibility
type AuthCodeProviderServer interface {
	CreateAuthCode(context.Context, *CreateAuthCodeRequest) (*CreateAuthCodeResponse, error)
	mustEmbedUnimplementedAuthCodeProviderServer()
}

// UnimplementedAuthCodeProviderServer must be embedded to have forward compatible implementations.
type UnimplementedAuthCodeProviderServer struct {
}

func (UnimplementedAuthCodeProviderServer) CreateAuthCode(context.Context, *CreateAuthCodeRequest) (*CreateAuthCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthCode not implemented")
}
func (UnimplementedAuthCodeProviderServer) mustEmbedUnimplementedAuthCodeProviderServer() {}

// UnsafeAuthCodeProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthCodeProviderServer will
// result in compilation errors.
type UnsafeAuthCodeProviderServer interface {
	mustEmbedUnimplementedAuthCodeProviderServer()
}

func RegisterAuthCodeProviderServer(s grpc.ServiceRegistrar, srv AuthCodeProviderServer) {
	s.RegisterService(&AuthCodeProvider_ServiceDesc, srv)
}

func _AuthCodeProvider_CreateAuthCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAuthCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthCodeProviderServer).CreateAuthCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthCodeProvider/CreateAuthCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthCodeProviderServer).CreateAuthCode(ctx, req.(*CreateAuthCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthCodeProvider_ServiceDesc is the grpc.ServiceDesc for AuthCodeProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthCodeProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthCodeProvider",
	HandlerType: (*AuthCodeProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAuthCode",
			Handler:    _AuthCodeProvider_CreateAuthCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// AuthTokenVerifierClient is the client API for AuthTokenVerifier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthTokenVerifierClient interface {
	// Verifies a token and returns claims
	Verify(ctx context.Context, in *VerifyTokenRequest, opts ...grpc.CallOption) (*VerifyTokenResponse, error)
}

type authTokenVerifierClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthTokenVerifierClient(cc grpc.ClientConnInterface) AuthTokenVerifierClient {
	return &authTokenVerifierClient{cc}
}

func (c *authTokenVerifierClient) Verify(ctx context.Context, in *VerifyTokenRequest, opts ...grpc.CallOption) (*VerifyTokenResponse, error) {
	out := new(VerifyTokenResponse)
	err := c.cc.Invoke(ctx, "/auth.AuthTokenVerifier/Verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthTokenVerifierServer is the server API for AuthTokenVerifier service.
// All implementations must embed UnimplementedAuthTokenVerifierServer
// for forward compatibility
type AuthTokenVerifierServer interface {
	// Verifies a token and returns claims
	Verify(context.Context, *VerifyTokenRequest) (*VerifyTokenResponse, error)
	mustEmbedUnimplementedAuthTokenVerifierServer()
}

// UnimplementedAuthTokenVerifierServer must be embedded to have forward compatible implementations.
type UnimplementedAuthTokenVerifierServer struct {
}

func (UnimplementedAuthTokenVerifierServer) Verify(context.Context, *VerifyTokenRequest) (*VerifyTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedAuthTokenVerifierServer) mustEmbedUnimplementedAuthTokenVerifierServer() {}

// UnsafeAuthTokenVerifierServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthTokenVerifierServer will
// result in compilation errors.
type UnsafeAuthTokenVerifierServer interface {
	mustEmbedUnimplementedAuthTokenVerifierServer()
}

func RegisterAuthTokenVerifierServer(s grpc.ServiceRegistrar, srv AuthTokenVerifierServer) {
	s.RegisterService(&AuthTokenVerifier_ServiceDesc, srv)
}

func _AuthTokenVerifier_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthTokenVerifierServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthTokenVerifier/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthTokenVerifierServer).Verify(ctx, req.(*VerifyTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthTokenVerifier_ServiceDesc is the grpc.ServiceDesc for AuthTokenVerifier service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthTokenVerifier_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthTokenVerifier",
	HandlerType: (*AuthTokenVerifierServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Verify",
			Handler:    _AuthTokenVerifier_Verify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// AuthCodeExchangerClient is the client API for AuthCodeExchanger service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthCodeExchangerClient interface {
	Exchange(ctx context.Context, in *ExchangeRequest, opts ...grpc.CallOption) (*ExchangeResponse, error)
}

type authCodeExchangerClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthCodeExchangerClient(cc grpc.ClientConnInterface) AuthCodeExchangerClient {
	return &authCodeExchangerClient{cc}
}

func (c *authCodeExchangerClient) Exchange(ctx context.Context, in *ExchangeRequest, opts ...grpc.CallOption) (*ExchangeResponse, error) {
	out := new(ExchangeResponse)
	err := c.cc.Invoke(ctx, "/auth.AuthCodeExchanger/Exchange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthCodeExchangerServer is the server API for AuthCodeExchanger service.
// All implementations must embed UnimplementedAuthCodeExchangerServer
// for forward compatibility
type AuthCodeExchangerServer interface {
	Exchange(context.Context, *ExchangeRequest) (*ExchangeResponse, error)
	mustEmbedUnimplementedAuthCodeExchangerServer()
}

// UnimplementedAuthCodeExchangerServer must be embedded to have forward compatible implementations.
type UnimplementedAuthCodeExchangerServer struct {
}

func (UnimplementedAuthCodeExchangerServer) Exchange(context.Context, *ExchangeRequest) (*ExchangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (UnimplementedAuthCodeExchangerServer) mustEmbedUnimplementedAuthCodeExchangerServer() {}

// UnsafeAuthCodeExchangerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthCodeExchangerServer will
// result in compilation errors.
type UnsafeAuthCodeExchangerServer interface {
	mustEmbedUnimplementedAuthCodeExchangerServer()
}

func RegisterAuthCodeExchangerServer(s grpc.ServiceRegistrar, srv AuthCodeExchangerServer) {
	s.RegisterService(&AuthCodeExchanger_ServiceDesc, srv)
}

func _AuthCodeExchanger_Exchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExchangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthCodeExchangerServer).Exchange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthCodeExchanger/Exchange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthCodeExchangerServer).Exchange(ctx, req.(*ExchangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthCodeExchanger_ServiceDesc is the grpc.ServiceDesc for AuthCodeExchanger service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthCodeExchanger_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthCodeExchanger",
	HandlerType: (*AuthCodeExchangerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Exchange",
			Handler:    _AuthCodeExchanger_Exchange_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// PasswordCredentialsCodeClient is the client API for PasswordCredentialsCode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PasswordCredentialsCodeClient interface {
	PasswordCredentialsCode(ctx context.Context, in *PasswordCredentialsCodeRequest, opts ...grpc.CallOption) (*PasswordCredentialsCodeResponse, error)
}

type passwordCredentialsCodeClient struct {
	cc grpc.ClientConnInterface
}

func NewPasswordCredentialsCodeClient(cc grpc.ClientConnInterface) PasswordCredentialsCodeClient {
	return &passwordCredentialsCodeClient{cc}
}

func (c *passwordCredentialsCodeClient) PasswordCredentialsCode(ctx context.Context, in *PasswordCredentialsCodeRequest, opts ...grpc.CallOption) (*PasswordCredentialsCodeResponse, error) {
	out := new(PasswordCredentialsCodeResponse)
	err := c.cc.Invoke(ctx, "/auth.PasswordCredentialsCode/PasswordCredentialsCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PasswordCredentialsCodeServer is the server API for PasswordCredentialsCode service.
// All implementations must embed UnimplementedPasswordCredentialsCodeServer
// for forward compatibility
type PasswordCredentialsCodeServer interface {
	PasswordCredentialsCode(context.Context, *PasswordCredentialsCodeRequest) (*PasswordCredentialsCodeResponse, error)
	mustEmbedUnimplementedPasswordCredentialsCodeServer()
}

// UnimplementedPasswordCredentialsCodeServer must be embedded to have forward compatible implementations.
type UnimplementedPasswordCredentialsCodeServer struct {
}

func (UnimplementedPasswordCredentialsCodeServer) PasswordCredentialsCode(context.Context, *PasswordCredentialsCodeRequest) (*PasswordCredentialsCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PasswordCredentialsCode not implemented")
}
func (UnimplementedPasswordCredentialsCodeServer) mustEmbedUnimplementedPasswordCredentialsCodeServer() {
}

// UnsafePasswordCredentialsCodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PasswordCredentialsCodeServer will
// result in compilation errors.
type UnsafePasswordCredentialsCodeServer interface {
	mustEmbedUnimplementedPasswordCredentialsCodeServer()
}

func RegisterPasswordCredentialsCodeServer(s grpc.ServiceRegistrar, srv PasswordCredentialsCodeServer) {
	s.RegisterService(&PasswordCredentialsCode_ServiceDesc, srv)
}

func _PasswordCredentialsCode_PasswordCredentialsCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordCredentialsCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasswordCredentialsCodeServer).PasswordCredentialsCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.PasswordCredentialsCode/PasswordCredentialsCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasswordCredentialsCodeServer).PasswordCredentialsCode(ctx, req.(*PasswordCredentialsCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PasswordCredentialsCode_ServiceDesc is the grpc.ServiceDesc for PasswordCredentialsCode service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PasswordCredentialsCode_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.PasswordCredentialsCode",
	HandlerType: (*PasswordCredentialsCodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PasswordCredentialsCode",
			Handler:    _PasswordCredentialsCode_PasswordCredentialsCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// PasswordCredentialsTokenClient is the client API for PasswordCredentialsToken service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PasswordCredentialsTokenClient interface {
	PasswordCredentialsToken(ctx context.Context, in *PasswordCredentialsTokenRequest, opts ...grpc.CallOption) (*PasswordCredentialsTokenResponse, error)
}

type passwordCredentialsTokenClient struct {
	cc grpc.ClientConnInterface
}

func NewPasswordCredentialsTokenClient(cc grpc.ClientConnInterface) PasswordCredentialsTokenClient {
	return &passwordCredentialsTokenClient{cc}
}

func (c *passwordCredentialsTokenClient) PasswordCredentialsToken(ctx context.Context, in *PasswordCredentialsTokenRequest, opts ...grpc.CallOption) (*PasswordCredentialsTokenResponse, error) {
	out := new(PasswordCredentialsTokenResponse)
	err := c.cc.Invoke(ctx, "/auth.PasswordCredentialsToken/PasswordCredentialsToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PasswordCredentialsTokenServer is the server API for PasswordCredentialsToken service.
// All implementations must embed UnimplementedPasswordCredentialsTokenServer
// for forward compatibility
type PasswordCredentialsTokenServer interface {
	PasswordCredentialsToken(context.Context, *PasswordCredentialsTokenRequest) (*PasswordCredentialsTokenResponse, error)
	mustEmbedUnimplementedPasswordCredentialsTokenServer()
}

// UnimplementedPasswordCredentialsTokenServer must be embedded to have forward compatible implementations.
type UnimplementedPasswordCredentialsTokenServer struct {
}

func (UnimplementedPasswordCredentialsTokenServer) PasswordCredentialsToken(context.Context, *PasswordCredentialsTokenRequest) (*PasswordCredentialsTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PasswordCredentialsToken not implemented")
}
func (UnimplementedPasswordCredentialsTokenServer) mustEmbedUnimplementedPasswordCredentialsTokenServer() {
}

// UnsafePasswordCredentialsTokenServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PasswordCredentialsTokenServer will
// result in compilation errors.
type UnsafePasswordCredentialsTokenServer interface {
	mustEmbedUnimplementedPasswordCredentialsTokenServer()
}

func RegisterPasswordCredentialsTokenServer(s grpc.ServiceRegistrar, srv PasswordCredentialsTokenServer) {
	s.RegisterService(&PasswordCredentialsToken_ServiceDesc, srv)
}

func _PasswordCredentialsToken_PasswordCredentialsToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordCredentialsTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PasswordCredentialsTokenServer).PasswordCredentialsToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.PasswordCredentialsToken/PasswordCredentialsToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PasswordCredentialsTokenServer).PasswordCredentialsToken(ctx, req.(*PasswordCredentialsTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PasswordCredentialsToken_ServiceDesc is the grpc.ServiceDesc for PasswordCredentialsToken service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PasswordCredentialsToken_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.PasswordCredentialsToken",
	HandlerType: (*PasswordCredentialsTokenServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PasswordCredentialsToken",
			Handler:    _PasswordCredentialsToken_PasswordCredentialsToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// LoginChallengeCodeClient is the client API for LoginChallengeCode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LoginChallengeCodeClient interface {
	LoginChallengeCode(ctx context.Context, in *LoginChallengeCodeRequest, opts ...grpc.CallOption) (*LoginChallengeCodeResponse, error)
}

type loginChallengeCodeClient struct {
	cc grpc.ClientConnInterface
}

func NewLoginChallengeCodeClient(cc grpc.ClientConnInterface) LoginChallengeCodeClient {
	return &loginChallengeCodeClient{cc}
}

func (c *loginChallengeCodeClient) LoginChallengeCode(ctx context.Context, in *LoginChallengeCodeRequest, opts ...grpc.CallOption) (*LoginChallengeCodeResponse, error) {
	out := new(LoginChallengeCodeResponse)
	err := c.cc.Invoke(ctx, "/auth.LoginChallengeCode/LoginChallengeCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LoginChallengeCodeServer is the server API for LoginChallengeCode service.
// All implementations must embed UnimplementedLoginChallengeCodeServer
// for forward compatibility
type LoginChallengeCodeServer interface {
	LoginChallengeCode(context.Context, *LoginChallengeCodeRequest) (*LoginChallengeCodeResponse, error)
	mustEmbedUnimplementedLoginChallengeCodeServer()
}

// UnimplementedLoginChallengeCodeServer must be embedded to have forward compatible implementations.
type UnimplementedLoginChallengeCodeServer struct {
}

func (UnimplementedLoginChallengeCodeServer) LoginChallengeCode(context.Context, *LoginChallengeCodeRequest) (*LoginChallengeCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginChallengeCode not implemented")
}
func (UnimplementedLoginChallengeCodeServer) mustEmbedUnimplementedLoginChallengeCodeServer() {}

// UnsafeLoginChallengeCodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LoginChallengeCodeServer will
// result in compilation errors.
type UnsafeLoginChallengeCodeServer interface {
	mustEmbedUnimplementedLoginChallengeCodeServer()
}

func RegisterLoginChallengeCodeServer(s grpc.ServiceRegistrar, srv LoginChallengeCodeServer) {
	s.RegisterService(&LoginChallengeCode_ServiceDesc, srv)
}

func _LoginChallengeCode_LoginChallengeCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginChallengeCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginChallengeCodeServer).LoginChallengeCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.LoginChallengeCode/LoginChallengeCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginChallengeCodeServer).LoginChallengeCode(ctx, req.(*LoginChallengeCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LoginChallengeCode_ServiceDesc is the grpc.ServiceDesc for LoginChallengeCode service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LoginChallengeCode_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.LoginChallengeCode",
	HandlerType: (*LoginChallengeCodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoginChallengeCode",
			Handler:    _LoginChallengeCode_LoginChallengeCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// AuthTokenRefresherClient is the client API for AuthTokenRefresher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthTokenRefresherClient interface {
	Refresh(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error)
}

type authTokenRefresherClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthTokenRefresherClient(cc grpc.ClientConnInterface) AuthTokenRefresherClient {
	return &authTokenRefresherClient{cc}
}

func (c *authTokenRefresherClient) Refresh(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*RefreshTokenResponse, error) {
	out := new(RefreshTokenResponse)
	err := c.cc.Invoke(ctx, "/auth.AuthTokenRefresher/Refresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthTokenRefresherServer is the server API for AuthTokenRefresher service.
// All implementations must embed UnimplementedAuthTokenRefresherServer
// for forward compatibility
type AuthTokenRefresherServer interface {
	Refresh(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error)
	mustEmbedUnimplementedAuthTokenRefresherServer()
}

// UnimplementedAuthTokenRefresherServer must be embedded to have forward compatible implementations.
type UnimplementedAuthTokenRefresherServer struct {
}

func (UnimplementedAuthTokenRefresherServer) Refresh(context.Context, *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedAuthTokenRefresherServer) mustEmbedUnimplementedAuthTokenRefresherServer() {}

// UnsafeAuthTokenRefresherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthTokenRefresherServer will
// result in compilation errors.
type UnsafeAuthTokenRefresherServer interface {
	mustEmbedUnimplementedAuthTokenRefresherServer()
}

func RegisterAuthTokenRefresherServer(s grpc.ServiceRegistrar, srv AuthTokenRefresherServer) {
	s.RegisterService(&AuthTokenRefresher_ServiceDesc, srv)
}

func _AuthTokenRefresher_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthTokenRefresherServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.AuthTokenRefresher/Refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthTokenRefresherServer).Refresh(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthTokenRefresher_ServiceDesc is the grpc.ServiceDesc for AuthTokenRefresher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthTokenRefresher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthTokenRefresher",
	HandlerType: (*AuthTokenRefresherServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Refresh",
			Handler:    _AuthTokenRefresher_Refresh_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}

// PersonalAccessTokenServiceClient is the client API for PersonalAccessTokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PersonalAccessTokenServiceClient interface {
	Generate(ctx context.Context, in *PatGenerateRequest, opts ...grpc.CallOption) (*PatGenerateResponse, error)
	Revoke(ctx context.Context, in *PatRevokeRequest, opts ...grpc.CallOption) (*PatRevokeResponse, error)
	List(ctx context.Context, in *PatListRequest, opts ...grpc.CallOption) (*PatListResponse, error)
}

type personalAccessTokenServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPersonalAccessTokenServiceClient(cc grpc.ClientConnInterface) PersonalAccessTokenServiceClient {
	return &personalAccessTokenServiceClient{cc}
}

func (c *personalAccessTokenServiceClient) Generate(ctx context.Context, in *PatGenerateRequest, opts ...grpc.CallOption) (*PatGenerateResponse, error) {
	out := new(PatGenerateResponse)
	err := c.cc.Invoke(ctx, "/auth.PersonalAccessTokenService/Generate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *personalAccessTokenServiceClient) Revoke(ctx context.Context, in *PatRevokeRequest, opts ...grpc.CallOption) (*PatRevokeResponse, error) {
	out := new(PatRevokeResponse)
	err := c.cc.Invoke(ctx, "/auth.PersonalAccessTokenService/Revoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *personalAccessTokenServiceClient) List(ctx context.Context, in *PatListRequest, opts ...grpc.CallOption) (*PatListResponse, error) {
	out := new(PatListResponse)
	err := c.cc.Invoke(ctx, "/auth.PersonalAccessTokenService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PersonalAccessTokenServiceServer is the server API for PersonalAccessTokenService service.
// All implementations must embed UnimplementedPersonalAccessTokenServiceServer
// for forward compatibility
type PersonalAccessTokenServiceServer interface {
	Generate(context.Context, *PatGenerateRequest) (*PatGenerateResponse, error)
	Revoke(context.Context, *PatRevokeRequest) (*PatRevokeResponse, error)
	List(context.Context, *PatListRequest) (*PatListResponse, error)
	mustEmbedUnimplementedPersonalAccessTokenServiceServer()
}

// UnimplementedPersonalAccessTokenServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPersonalAccessTokenServiceServer struct {
}

func (UnimplementedPersonalAccessTokenServiceServer) Generate(context.Context, *PatGenerateRequest) (*PatGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}
func (UnimplementedPersonalAccessTokenServiceServer) Revoke(context.Context, *PatRevokeRequest) (*PatRevokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (UnimplementedPersonalAccessTokenServiceServer) List(context.Context, *PatListRequest) (*PatListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPersonalAccessTokenServiceServer) mustEmbedUnimplementedPersonalAccessTokenServiceServer() {
}

// UnsafePersonalAccessTokenServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PersonalAccessTokenServiceServer will
// result in compilation errors.
type UnsafePersonalAccessTokenServiceServer interface {
	mustEmbedUnimplementedPersonalAccessTokenServiceServer()
}

func RegisterPersonalAccessTokenServiceServer(s grpc.ServiceRegistrar, srv PersonalAccessTokenServiceServer) {
	s.RegisterService(&PersonalAccessTokenService_ServiceDesc, srv)
}

func _PersonalAccessTokenService_Generate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PersonalAccessTokenServiceServer).Generate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.PersonalAccessTokenService/Generate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PersonalAccessTokenServiceServer).Generate(ctx, req.(*PatGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PersonalAccessTokenService_Revoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatRevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PersonalAccessTokenServiceServer).Revoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.PersonalAccessTokenService/Revoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PersonalAccessTokenServiceServer).Revoke(ctx, req.(*PatRevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PersonalAccessTokenService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PersonalAccessTokenServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auth.PersonalAccessTokenService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PersonalAccessTokenServiceServer).List(ctx, req.(*PatListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PersonalAccessTokenService_ServiceDesc is the grpc.ServiceDesc for PersonalAccessTokenService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PersonalAccessTokenService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.PersonalAccessTokenService",
	HandlerType: (*PersonalAccessTokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Generate",
			Handler:    _PersonalAccessTokenService_Generate_Handler,
		},
		{
			MethodName: "Revoke",
			Handler:    _PersonalAccessTokenService_Revoke_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PersonalAccessTokenService_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-auth.proto",
}
