// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-service.proto

package service

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedServiceManagerServers     = make(map[string]ServiceManagerEnhancedServer)
	enhancedServiceManagerServersLock = sync.RWMutex{}
)

type NamedServiceManagerServer interface {
	ServiceManagerServer
	Name() string
}
type ServiceManagerEnhancedServer map[string]NamedServiceManagerServer

func (m ServiceManagerEnhancedServer) Start(ctx context.Context, r *StartRequest) (*StartResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Start should have a context")
	}
	enhancedServiceManagerServersLock.RLock()
	defer enhancedServiceManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Start(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}

func (m ServiceManagerEnhancedServer) Stop(ctx context.Context, r *StopRequest) (*StopResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Stop should have a context")
	}
	enhancedServiceManagerServersLock.RLock()
	defer enhancedServiceManagerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Stop(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (m ServiceManagerEnhancedServer) mustEmbedUnimplementedServiceManagerServer() {}
func RegisterServiceManagerEnhancedServer(s grpc.ServiceRegistrar, srv NamedServiceManagerServer) {
	enhancedServiceManagerServersLock.Lock()
	defer enhancedServiceManagerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedServiceManagerServers[addr]
	if !ok {
		m = ServiceManagerEnhancedServer{}
		enhancedServiceManagerServers[addr] = m
		RegisterServiceManagerServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterServiceManagerEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedServiceManagerServersLock.Lock()
	defer enhancedServiceManagerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedServiceManagerServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedLoginModifierServers     = make(map[string]LoginModifierEnhancedServer)
	enhancedLoginModifierServersLock = sync.RWMutex{}
)

type NamedLoginModifierServer interface {
	LoginModifierServer
	Name() string
}
type LoginModifierEnhancedServer map[string]NamedLoginModifierServer

func (m LoginModifierEnhancedServer) ModifyLogin(ctx context.Context, r *ModifyLoginRequest) (*ModifyLoginResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method ModifyLogin should have a context")
	}
	enhancedLoginModifierServersLock.RLock()
	defer enhancedLoginModifierServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ModifyLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method ModifyLogin not implemented")
}
func (m LoginModifierEnhancedServer) mustEmbedUnimplementedLoginModifierServer() {}
func RegisterLoginModifierEnhancedServer(s grpc.ServiceRegistrar, srv NamedLoginModifierServer) {
	enhancedLoginModifierServersLock.Lock()
	defer enhancedLoginModifierServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedLoginModifierServers[addr]
	if !ok {
		m = LoginModifierEnhancedServer{}
		enhancedLoginModifierServers[addr] = m
		RegisterLoginModifierServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterLoginModifierEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedLoginModifierServersLock.Lock()
	defer enhancedLoginModifierServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedLoginModifierServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
