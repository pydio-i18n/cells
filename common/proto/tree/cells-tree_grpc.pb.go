// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package tree

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NodeProviderClient is the client API for NodeProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeProviderClient interface {
	ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...grpc.CallOption) (*ReadNodeResponse, error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (NodeProvider_ListNodesClient, error)
}

type nodeProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeProviderClient(cc grpc.ClientConnInterface) NodeProviderClient {
	return &nodeProviderClient{cc}
}

func (c *nodeProviderClient) ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...grpc.CallOption) (*ReadNodeResponse, error) {
	out := new(ReadNodeResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeProvider/ReadNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeProviderClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (NodeProvider_ListNodesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeProvider_ServiceDesc.Streams[0], "/tree.NodeProvider/ListNodes", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeProviderListNodesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeProvider_ListNodesClient interface {
	Recv() (*ListNodesResponse, error)
	grpc.ClientStream
}

type nodeProviderListNodesClient struct {
	grpc.ClientStream
}

func (x *nodeProviderListNodesClient) Recv() (*ListNodesResponse, error) {
	m := new(ListNodesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeProviderServer is the server API for NodeProvider service.
// All implementations must embed UnimplementedNodeProviderServer
// for forward compatibility
type NodeProviderServer interface {
	ReadNode(context.Context, *ReadNodeRequest) (*ReadNodeResponse, error)
	ListNodes(*ListNodesRequest, NodeProvider_ListNodesServer) error
	mustEmbedUnimplementedNodeProviderServer()
}

// UnimplementedNodeProviderServer must be embedded to have forward compatible implementations.
type UnimplementedNodeProviderServer struct {
}

func (UnimplementedNodeProviderServer) ReadNode(context.Context, *ReadNodeRequest) (*ReadNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadNode not implemented")
}
func (UnimplementedNodeProviderServer) ListNodes(*ListNodesRequest, NodeProvider_ListNodesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedNodeProviderServer) mustEmbedUnimplementedNodeProviderServer() {}

// UnsafeNodeProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeProviderServer will
// result in compilation errors.
type UnsafeNodeProviderServer interface {
	mustEmbedUnimplementedNodeProviderServer()
}

func RegisterNodeProviderServer(s grpc.ServiceRegistrar, srv NodeProviderServer) {
	s.RegisterService(&NodeProvider_ServiceDesc, srv)
}

func _NodeProvider_ReadNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeProviderServer).ReadNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeProvider/ReadNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeProviderServer).ReadNode(ctx, req.(*ReadNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeProvider_ListNodes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListNodesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeProviderServer).ListNodes(m, &nodeProviderListNodesServer{stream})
}

type NodeProvider_ListNodesServer interface {
	Send(*ListNodesResponse) error
	grpc.ServerStream
}

type nodeProviderListNodesServer struct {
	grpc.ServerStream
}

func (x *nodeProviderListNodesServer) Send(m *ListNodesResponse) error {
	return x.ServerStream.SendMsg(m)
}

// NodeProvider_ServiceDesc is the grpc.ServiceDesc for NodeProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeProvider",
	HandlerType: (*NodeProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadNode",
			Handler:    _NodeProvider_ReadNode_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListNodes",
			Handler:       _NodeProvider_ListNodes_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// NodeProviderStreamerClient is the client API for NodeProviderStreamer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeProviderStreamerClient interface {
	ReadNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error)
}

type nodeProviderStreamerClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeProviderStreamerClient(cc grpc.ClientConnInterface) NodeProviderStreamerClient {
	return &nodeProviderStreamerClient{cc}
}

func (c *nodeProviderStreamerClient) ReadNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeProviderStreamer_ServiceDesc.Streams[0], "/tree.NodeProviderStreamer/ReadNodeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeProviderStreamerReadNodeStreamClient{stream}
	return x, nil
}

type NodeProviderStreamer_ReadNodeStreamClient interface {
	Send(*ReadNodeRequest) error
	Recv() (*ReadNodeResponse, error)
	grpc.ClientStream
}

type nodeProviderStreamerReadNodeStreamClient struct {
	grpc.ClientStream
}

func (x *nodeProviderStreamerReadNodeStreamClient) Send(m *ReadNodeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Recv() (*ReadNodeResponse, error) {
	m := new(ReadNodeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeProviderStreamerServer is the server API for NodeProviderStreamer service.
// All implementations must embed UnimplementedNodeProviderStreamerServer
// for forward compatibility
type NodeProviderStreamerServer interface {
	ReadNodeStream(NodeProviderStreamer_ReadNodeStreamServer) error
	mustEmbedUnimplementedNodeProviderStreamerServer()
}

// UnimplementedNodeProviderStreamerServer must be embedded to have forward compatible implementations.
type UnimplementedNodeProviderStreamerServer struct {
}

func (UnimplementedNodeProviderStreamerServer) ReadNodeStream(NodeProviderStreamer_ReadNodeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method ReadNodeStream not implemented")
}
func (UnimplementedNodeProviderStreamerServer) mustEmbedUnimplementedNodeProviderStreamerServer() {}

// UnsafeNodeProviderStreamerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeProviderStreamerServer will
// result in compilation errors.
type UnsafeNodeProviderStreamerServer interface {
	mustEmbedUnimplementedNodeProviderStreamerServer()
}

func RegisterNodeProviderStreamerServer(s grpc.ServiceRegistrar, srv NodeProviderStreamerServer) {
	s.RegisterService(&NodeProviderStreamer_ServiceDesc, srv)
}

func _NodeProviderStreamer_ReadNodeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeProviderStreamerServer).ReadNodeStream(&nodeProviderStreamerReadNodeStreamServer{stream})
}

type NodeProviderStreamer_ReadNodeStreamServer interface {
	Send(*ReadNodeResponse) error
	Recv() (*ReadNodeRequest, error)
	grpc.ServerStream
}

type nodeProviderStreamerReadNodeStreamServer struct {
	grpc.ServerStream
}

func (x *nodeProviderStreamerReadNodeStreamServer) Send(m *ReadNodeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeProviderStreamerReadNodeStreamServer) Recv() (*ReadNodeRequest, error) {
	m := new(ReadNodeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeProviderStreamer_ServiceDesc is the grpc.ServiceDesc for NodeProviderStreamer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeProviderStreamer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeProviderStreamer",
	HandlerType: (*NodeProviderStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadNodeStream",
			Handler:       _NodeProviderStreamer_ReadNodeStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// NodeChangesStreamerClient is the client API for NodeChangesStreamer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeChangesStreamerClient interface {
	StreamChanges(ctx context.Context, in *StreamChangesRequest, opts ...grpc.CallOption) (NodeChangesStreamer_StreamChangesClient, error)
}

type nodeChangesStreamerClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeChangesStreamerClient(cc grpc.ClientConnInterface) NodeChangesStreamerClient {
	return &nodeChangesStreamerClient{cc}
}

func (c *nodeChangesStreamerClient) StreamChanges(ctx context.Context, in *StreamChangesRequest, opts ...grpc.CallOption) (NodeChangesStreamer_StreamChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeChangesStreamer_ServiceDesc.Streams[0], "/tree.NodeChangesStreamer/StreamChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeChangesStreamerStreamChangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeChangesStreamer_StreamChangesClient interface {
	Recv() (*NodeChangeEvent, error)
	grpc.ClientStream
}

type nodeChangesStreamerStreamChangesClient struct {
	grpc.ClientStream
}

func (x *nodeChangesStreamerStreamChangesClient) Recv() (*NodeChangeEvent, error) {
	m := new(NodeChangeEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeChangesStreamerServer is the server API for NodeChangesStreamer service.
// All implementations must embed UnimplementedNodeChangesStreamerServer
// for forward compatibility
type NodeChangesStreamerServer interface {
	StreamChanges(*StreamChangesRequest, NodeChangesStreamer_StreamChangesServer) error
	mustEmbedUnimplementedNodeChangesStreamerServer()
}

// UnimplementedNodeChangesStreamerServer must be embedded to have forward compatible implementations.
type UnimplementedNodeChangesStreamerServer struct {
}

func (UnimplementedNodeChangesStreamerServer) StreamChanges(*StreamChangesRequest, NodeChangesStreamer_StreamChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamChanges not implemented")
}
func (UnimplementedNodeChangesStreamerServer) mustEmbedUnimplementedNodeChangesStreamerServer() {}

// UnsafeNodeChangesStreamerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeChangesStreamerServer will
// result in compilation errors.
type UnsafeNodeChangesStreamerServer interface {
	mustEmbedUnimplementedNodeChangesStreamerServer()
}

func RegisterNodeChangesStreamerServer(s grpc.ServiceRegistrar, srv NodeChangesStreamerServer) {
	s.RegisterService(&NodeChangesStreamer_ServiceDesc, srv)
}

func _NodeChangesStreamer_StreamChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamChangesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeChangesStreamerServer).StreamChanges(m, &nodeChangesStreamerStreamChangesServer{stream})
}

type NodeChangesStreamer_StreamChangesServer interface {
	Send(*NodeChangeEvent) error
	grpc.ServerStream
}

type nodeChangesStreamerStreamChangesServer struct {
	grpc.ServerStream
}

func (x *nodeChangesStreamerStreamChangesServer) Send(m *NodeChangeEvent) error {
	return x.ServerStream.SendMsg(m)
}

// NodeChangesStreamer_ServiceDesc is the grpc.ServiceDesc for NodeChangesStreamer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeChangesStreamer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeChangesStreamer",
	HandlerType: (*NodeChangesStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamChanges",
			Handler:       _NodeChangesStreamer_StreamChanges_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// NodeChangesReceiverStreamerClient is the client API for NodeChangesReceiverStreamer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeChangesReceiverStreamerClient interface {
	PostNodeChanges(ctx context.Context, opts ...grpc.CallOption) (NodeChangesReceiverStreamer_PostNodeChangesClient, error)
}

type nodeChangesReceiverStreamerClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeChangesReceiverStreamerClient(cc grpc.ClientConnInterface) NodeChangesReceiverStreamerClient {
	return &nodeChangesReceiverStreamerClient{cc}
}

func (c *nodeChangesReceiverStreamerClient) PostNodeChanges(ctx context.Context, opts ...grpc.CallOption) (NodeChangesReceiverStreamer_PostNodeChangesClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeChangesReceiverStreamer_ServiceDesc.Streams[0], "/tree.NodeChangesReceiverStreamer/PostNodeChanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeChangesReceiverStreamerPostNodeChangesClient{stream}
	return x, nil
}

type NodeChangesReceiverStreamer_PostNodeChangesClient interface {
	Send(*NodeChangeEvent) error
	Recv() (*NodeChangeEvent, error)
	grpc.ClientStream
}

type nodeChangesReceiverStreamerPostNodeChangesClient struct {
	grpc.ClientStream
}

func (x *nodeChangesReceiverStreamerPostNodeChangesClient) Send(m *NodeChangeEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeChangesReceiverStreamerPostNodeChangesClient) Recv() (*NodeChangeEvent, error) {
	m := new(NodeChangeEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeChangesReceiverStreamerServer is the server API for NodeChangesReceiverStreamer service.
// All implementations must embed UnimplementedNodeChangesReceiverStreamerServer
// for forward compatibility
type NodeChangesReceiverStreamerServer interface {
	PostNodeChanges(NodeChangesReceiverStreamer_PostNodeChangesServer) error
	mustEmbedUnimplementedNodeChangesReceiverStreamerServer()
}

// UnimplementedNodeChangesReceiverStreamerServer must be embedded to have forward compatible implementations.
type UnimplementedNodeChangesReceiverStreamerServer struct {
}

func (UnimplementedNodeChangesReceiverStreamerServer) PostNodeChanges(NodeChangesReceiverStreamer_PostNodeChangesServer) error {
	return status.Errorf(codes.Unimplemented, "method PostNodeChanges not implemented")
}
func (UnimplementedNodeChangesReceiverStreamerServer) mustEmbedUnimplementedNodeChangesReceiverStreamerServer() {
}

// UnsafeNodeChangesReceiverStreamerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeChangesReceiverStreamerServer will
// result in compilation errors.
type UnsafeNodeChangesReceiverStreamerServer interface {
	mustEmbedUnimplementedNodeChangesReceiverStreamerServer()
}

func RegisterNodeChangesReceiverStreamerServer(s grpc.ServiceRegistrar, srv NodeChangesReceiverStreamerServer) {
	s.RegisterService(&NodeChangesReceiverStreamer_ServiceDesc, srv)
}

func _NodeChangesReceiverStreamer_PostNodeChanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeChangesReceiverStreamerServer).PostNodeChanges(&nodeChangesReceiverStreamerPostNodeChangesServer{stream})
}

type NodeChangesReceiverStreamer_PostNodeChangesServer interface {
	Send(*NodeChangeEvent) error
	Recv() (*NodeChangeEvent, error)
	grpc.ServerStream
}

type nodeChangesReceiverStreamerPostNodeChangesServer struct {
	grpc.ServerStream
}

func (x *nodeChangesReceiverStreamerPostNodeChangesServer) Send(m *NodeChangeEvent) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeChangesReceiverStreamerPostNodeChangesServer) Recv() (*NodeChangeEvent, error) {
	m := new(NodeChangeEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeChangesReceiverStreamer_ServiceDesc is the grpc.ServiceDesc for NodeChangesReceiverStreamer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeChangesReceiverStreamer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeChangesReceiverStreamer",
	HandlerType: (*NodeChangesReceiverStreamerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PostNodeChanges",
			Handler:       _NodeChangesReceiverStreamer_PostNodeChanges_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// NodeReceiverClient is the client API for NodeReceiver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeReceiverClient interface {
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error)
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*UpdateNodeResponse, error)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error)
}

type nodeReceiverClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeReceiverClient(cc grpc.ClientConnInterface) NodeReceiverClient {
	return &nodeReceiverClient{cc}
}

func (c *nodeReceiverClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateNodeResponse, error) {
	out := new(CreateNodeResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeReceiver/CreateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*UpdateNodeResponse, error) {
	out := new(UpdateNodeResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeReceiver/UpdateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error) {
	out := new(DeleteNodeResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeReceiver/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeReceiverServer is the server API for NodeReceiver service.
// All implementations must embed UnimplementedNodeReceiverServer
// for forward compatibility
type NodeReceiverServer interface {
	CreateNode(context.Context, *CreateNodeRequest) (*CreateNodeResponse, error)
	UpdateNode(context.Context, *UpdateNodeRequest) (*UpdateNodeResponse, error)
	DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error)
	mustEmbedUnimplementedNodeReceiverServer()
}

// UnimplementedNodeReceiverServer must be embedded to have forward compatible implementations.
type UnimplementedNodeReceiverServer struct {
}

func (UnimplementedNodeReceiverServer) CreateNode(context.Context, *CreateNodeRequest) (*CreateNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}
func (UnimplementedNodeReceiverServer) UpdateNode(context.Context, *UpdateNodeRequest) (*UpdateNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}
func (UnimplementedNodeReceiverServer) DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedNodeReceiverServer) mustEmbedUnimplementedNodeReceiverServer() {}

// UnsafeNodeReceiverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeReceiverServer will
// result in compilation errors.
type UnsafeNodeReceiverServer interface {
	mustEmbedUnimplementedNodeReceiverServer()
}

func RegisterNodeReceiverServer(s grpc.ServiceRegistrar, srv NodeReceiverServer) {
	s.RegisterService(&NodeReceiver_ServiceDesc, srv)
}

func _NodeReceiver_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeReceiverServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeReceiver/CreateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeReceiverServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeReceiver_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeReceiverServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeReceiver/UpdateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeReceiverServer).UpdateNode(ctx, req.(*UpdateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeReceiver_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeReceiverServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeReceiver/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeReceiverServer).DeleteNode(ctx, req.(*DeleteNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeReceiver_ServiceDesc is the grpc.ServiceDesc for NodeReceiver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeReceiver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeReceiver",
	HandlerType: (*NodeReceiverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNode",
			Handler:    _NodeReceiver_CreateNode_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _NodeReceiver_UpdateNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _NodeReceiver_DeleteNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-tree.proto",
}

// NodeReceiverStreamClient is the client API for NodeReceiverStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeReceiverStreamClient interface {
	CreateNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeReceiverStream_CreateNodeStreamClient, error)
	UpdateNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeReceiverStream_UpdateNodeStreamClient, error)
	DeleteNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeReceiverStream_DeleteNodeStreamClient, error)
}

type nodeReceiverStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeReceiverStreamClient(cc grpc.ClientConnInterface) NodeReceiverStreamClient {
	return &nodeReceiverStreamClient{cc}
}

func (c *nodeReceiverStreamClient) CreateNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeReceiverStream_CreateNodeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeReceiverStream_ServiceDesc.Streams[0], "/tree.NodeReceiverStream/CreateNodeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeReceiverStreamCreateNodeStreamClient{stream}
	return x, nil
}

type NodeReceiverStream_CreateNodeStreamClient interface {
	Send(*CreateNodeRequest) error
	Recv() (*CreateNodeResponse, error)
	grpc.ClientStream
}

type nodeReceiverStreamCreateNodeStreamClient struct {
	grpc.ClientStream
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Send(m *CreateNodeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Recv() (*CreateNodeResponse, error) {
	m := new(CreateNodeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeReceiverStreamClient) UpdateNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeReceiverStream_UpdateNodeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeReceiverStream_ServiceDesc.Streams[1], "/tree.NodeReceiverStream/UpdateNodeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeReceiverStreamUpdateNodeStreamClient{stream}
	return x, nil
}

type NodeReceiverStream_UpdateNodeStreamClient interface {
	Send(*UpdateNodeRequest) error
	Recv() (*UpdateNodeResponse, error)
	grpc.ClientStream
}

type nodeReceiverStreamUpdateNodeStreamClient struct {
	grpc.ClientStream
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Send(m *UpdateNodeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Recv() (*UpdateNodeResponse, error) {
	m := new(UpdateNodeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeReceiverStreamClient) DeleteNodeStream(ctx context.Context, opts ...grpc.CallOption) (NodeReceiverStream_DeleteNodeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeReceiverStream_ServiceDesc.Streams[2], "/tree.NodeReceiverStream/DeleteNodeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeReceiverStreamDeleteNodeStreamClient{stream}
	return x, nil
}

type NodeReceiverStream_DeleteNodeStreamClient interface {
	Send(*DeleteNodeRequest) error
	Recv() (*DeleteNodeResponse, error)
	grpc.ClientStream
}

type nodeReceiverStreamDeleteNodeStreamClient struct {
	grpc.ClientStream
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Send(m *DeleteNodeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Recv() (*DeleteNodeResponse, error) {
	m := new(DeleteNodeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeReceiverStreamServer is the server API for NodeReceiverStream service.
// All implementations must embed UnimplementedNodeReceiverStreamServer
// for forward compatibility
type NodeReceiverStreamServer interface {
	CreateNodeStream(NodeReceiverStream_CreateNodeStreamServer) error
	UpdateNodeStream(NodeReceiverStream_UpdateNodeStreamServer) error
	DeleteNodeStream(NodeReceiverStream_DeleteNodeStreamServer) error
	mustEmbedUnimplementedNodeReceiverStreamServer()
}

// UnimplementedNodeReceiverStreamServer must be embedded to have forward compatible implementations.
type UnimplementedNodeReceiverStreamServer struct {
}

func (UnimplementedNodeReceiverStreamServer) CreateNodeStream(NodeReceiverStream_CreateNodeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateNodeStream not implemented")
}
func (UnimplementedNodeReceiverStreamServer) UpdateNodeStream(NodeReceiverStream_UpdateNodeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateNodeStream not implemented")
}
func (UnimplementedNodeReceiverStreamServer) DeleteNodeStream(NodeReceiverStream_DeleteNodeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DeleteNodeStream not implemented")
}
func (UnimplementedNodeReceiverStreamServer) mustEmbedUnimplementedNodeReceiverStreamServer() {}

// UnsafeNodeReceiverStreamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeReceiverStreamServer will
// result in compilation errors.
type UnsafeNodeReceiverStreamServer interface {
	mustEmbedUnimplementedNodeReceiverStreamServer()
}

func RegisterNodeReceiverStreamServer(s grpc.ServiceRegistrar, srv NodeReceiverStreamServer) {
	s.RegisterService(&NodeReceiverStream_ServiceDesc, srv)
}

func _NodeReceiverStream_CreateNodeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeReceiverStreamServer).CreateNodeStream(&nodeReceiverStreamCreateNodeStreamServer{stream})
}

type NodeReceiverStream_CreateNodeStreamServer interface {
	Send(*CreateNodeResponse) error
	Recv() (*CreateNodeRequest, error)
	grpc.ServerStream
}

type nodeReceiverStreamCreateNodeStreamServer struct {
	grpc.ServerStream
}

func (x *nodeReceiverStreamCreateNodeStreamServer) Send(m *CreateNodeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeReceiverStreamCreateNodeStreamServer) Recv() (*CreateNodeRequest, error) {
	m := new(CreateNodeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NodeReceiverStream_UpdateNodeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeReceiverStreamServer).UpdateNodeStream(&nodeReceiverStreamUpdateNodeStreamServer{stream})
}

type NodeReceiverStream_UpdateNodeStreamServer interface {
	Send(*UpdateNodeResponse) error
	Recv() (*UpdateNodeRequest, error)
	grpc.ServerStream
}

type nodeReceiverStreamUpdateNodeStreamServer struct {
	grpc.ServerStream
}

func (x *nodeReceiverStreamUpdateNodeStreamServer) Send(m *UpdateNodeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamServer) Recv() (*UpdateNodeRequest, error) {
	m := new(UpdateNodeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NodeReceiverStream_DeleteNodeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeReceiverStreamServer).DeleteNodeStream(&nodeReceiverStreamDeleteNodeStreamServer{stream})
}

type NodeReceiverStream_DeleteNodeStreamServer interface {
	Send(*DeleteNodeResponse) error
	Recv() (*DeleteNodeRequest, error)
	grpc.ServerStream
}

type nodeReceiverStreamDeleteNodeStreamServer struct {
	grpc.ServerStream
}

func (x *nodeReceiverStreamDeleteNodeStreamServer) Send(m *DeleteNodeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamServer) Recv() (*DeleteNodeRequest, error) {
	m := new(DeleteNodeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeReceiverStream_ServiceDesc is the grpc.ServiceDesc for NodeReceiverStream service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeReceiverStream_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeReceiverStream",
	HandlerType: (*NodeReceiverStreamServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateNodeStream",
			Handler:       _NodeReceiverStream_CreateNodeStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateNodeStream",
			Handler:       _NodeReceiverStream_UpdateNodeStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DeleteNodeStream",
			Handler:       _NodeReceiverStream_DeleteNodeStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// SessionIndexerClient is the client API for SessionIndexer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionIndexerClient interface {
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionResponse, error)
	FlushSession(ctx context.Context, in *FlushSessionRequest, opts ...grpc.CallOption) (*FlushSessionResponse, error)
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error)
}

type sessionIndexerClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionIndexerClient(cc grpc.ClientConnInterface) SessionIndexerClient {
	return &sessionIndexerClient{cc}
}

func (c *sessionIndexerClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionResponse, error) {
	out := new(OpenSessionResponse)
	err := c.cc.Invoke(ctx, "/tree.SessionIndexer/OpenSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionIndexerClient) FlushSession(ctx context.Context, in *FlushSessionRequest, opts ...grpc.CallOption) (*FlushSessionResponse, error) {
	out := new(FlushSessionResponse)
	err := c.cc.Invoke(ctx, "/tree.SessionIndexer/FlushSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionIndexerClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error) {
	out := new(CloseSessionResponse)
	err := c.cc.Invoke(ctx, "/tree.SessionIndexer/CloseSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionIndexerServer is the server API for SessionIndexer service.
// All implementations must embed UnimplementedSessionIndexerServer
// for forward compatibility
type SessionIndexerServer interface {
	OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionResponse, error)
	FlushSession(context.Context, *FlushSessionRequest) (*FlushSessionResponse, error)
	CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error)
	mustEmbedUnimplementedSessionIndexerServer()
}

// UnimplementedSessionIndexerServer must be embedded to have forward compatible implementations.
type UnimplementedSessionIndexerServer struct {
}

func (UnimplementedSessionIndexerServer) OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenSession not implemented")
}
func (UnimplementedSessionIndexerServer) FlushSession(context.Context, *FlushSessionRequest) (*FlushSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlushSession not implemented")
}
func (UnimplementedSessionIndexerServer) CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}
func (UnimplementedSessionIndexerServer) mustEmbedUnimplementedSessionIndexerServer() {}

// UnsafeSessionIndexerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionIndexerServer will
// result in compilation errors.
type UnsafeSessionIndexerServer interface {
	mustEmbedUnimplementedSessionIndexerServer()
}

func RegisterSessionIndexerServer(s grpc.ServiceRegistrar, srv SessionIndexerServer) {
	s.RegisterService(&SessionIndexer_ServiceDesc, srv)
}

func _SessionIndexer_OpenSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionIndexerServer).OpenSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.SessionIndexer/OpenSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionIndexerServer).OpenSession(ctx, req.(*OpenSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionIndexer_FlushSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlushSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionIndexerServer).FlushSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.SessionIndexer/FlushSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionIndexerServer).FlushSession(ctx, req.(*FlushSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionIndexer_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionIndexerServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.SessionIndexer/CloseSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionIndexerServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionIndexer_ServiceDesc is the grpc.ServiceDesc for SessionIndexer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionIndexer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.SessionIndexer",
	HandlerType: (*SessionIndexerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenSession",
			Handler:    _SessionIndexer_OpenSession_Handler,
		},
		{
			MethodName: "FlushSession",
			Handler:    _SessionIndexer_FlushSession_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _SessionIndexer_CloseSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-tree.proto",
}

// NodeEventsProviderClient is the client API for NodeEventsProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeEventsProviderClient interface {
	WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...grpc.CallOption) (NodeEventsProvider_WatchNodeClient, error)
}

type nodeEventsProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeEventsProviderClient(cc grpc.ClientConnInterface) NodeEventsProviderClient {
	return &nodeEventsProviderClient{cc}
}

func (c *nodeEventsProviderClient) WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...grpc.CallOption) (NodeEventsProvider_WatchNodeClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeEventsProvider_ServiceDesc.Streams[0], "/tree.NodeEventsProvider/WatchNode", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeEventsProviderWatchNodeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeEventsProvider_WatchNodeClient interface {
	Recv() (*WatchNodeResponse, error)
	grpc.ClientStream
}

type nodeEventsProviderWatchNodeClient struct {
	grpc.ClientStream
}

func (x *nodeEventsProviderWatchNodeClient) Recv() (*WatchNodeResponse, error) {
	m := new(WatchNodeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NodeEventsProviderServer is the server API for NodeEventsProvider service.
// All implementations must embed UnimplementedNodeEventsProviderServer
// for forward compatibility
type NodeEventsProviderServer interface {
	WatchNode(*WatchNodeRequest, NodeEventsProvider_WatchNodeServer) error
	mustEmbedUnimplementedNodeEventsProviderServer()
}

// UnimplementedNodeEventsProviderServer must be embedded to have forward compatible implementations.
type UnimplementedNodeEventsProviderServer struct {
}

func (UnimplementedNodeEventsProviderServer) WatchNode(*WatchNodeRequest, NodeEventsProvider_WatchNodeServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchNode not implemented")
}
func (UnimplementedNodeEventsProviderServer) mustEmbedUnimplementedNodeEventsProviderServer() {}

// UnsafeNodeEventsProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeEventsProviderServer will
// result in compilation errors.
type UnsafeNodeEventsProviderServer interface {
	mustEmbedUnimplementedNodeEventsProviderServer()
}

func RegisterNodeEventsProviderServer(s grpc.ServiceRegistrar, srv NodeEventsProviderServer) {
	s.RegisterService(&NodeEventsProvider_ServiceDesc, srv)
}

func _NodeEventsProvider_WatchNode_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchNodeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeEventsProviderServer).WatchNode(m, &nodeEventsProviderWatchNodeServer{stream})
}

type NodeEventsProvider_WatchNodeServer interface {
	Send(*WatchNodeResponse) error
	grpc.ServerStream
}

type nodeEventsProviderWatchNodeServer struct {
	grpc.ServerStream
}

func (x *nodeEventsProviderWatchNodeServer) Send(m *WatchNodeResponse) error {
	return x.ServerStream.SendMsg(m)
}

// NodeEventsProvider_ServiceDesc is the grpc.ServiceDesc for NodeEventsProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeEventsProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeEventsProvider",
	HandlerType: (*NodeEventsProviderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchNode",
			Handler:       _NodeEventsProvider_WatchNode_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// SearcherClient is the client API for Searcher service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearcherClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (Searcher_SearchClient, error)
}

type searcherClient struct {
	cc grpc.ClientConnInterface
}

func NewSearcherClient(cc grpc.ClientConnInterface) SearcherClient {
	return &searcherClient{cc}
}

func (c *searcherClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (Searcher_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Searcher_ServiceDesc.Streams[0], "/tree.Searcher/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &searcherSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Searcher_SearchClient interface {
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type searcherSearchClient struct {
	grpc.ClientStream
}

func (x *searcherSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SearcherServer is the server API for Searcher service.
// All implementations must embed UnimplementedSearcherServer
// for forward compatibility
type SearcherServer interface {
	Search(*SearchRequest, Searcher_SearchServer) error
	mustEmbedUnimplementedSearcherServer()
}

// UnimplementedSearcherServer must be embedded to have forward compatible implementations.
type UnimplementedSearcherServer struct {
}

func (UnimplementedSearcherServer) Search(*SearchRequest, Searcher_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSearcherServer) mustEmbedUnimplementedSearcherServer() {}

// UnsafeSearcherServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearcherServer will
// result in compilation errors.
type UnsafeSearcherServer interface {
	mustEmbedUnimplementedSearcherServer()
}

func RegisterSearcherServer(s grpc.ServiceRegistrar, srv SearcherServer) {
	s.RegisterService(&Searcher_ServiceDesc, srv)
}

func _Searcher_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SearcherServer).Search(m, &searcherSearchServer{stream})
}

type Searcher_SearchServer interface {
	Send(*SearchResponse) error
	grpc.ServerStream
}

type searcherSearchServer struct {
	grpc.ServerStream
}

func (x *searcherSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Searcher_ServiceDesc is the grpc.ServiceDesc for Searcher service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Searcher_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.Searcher",
	HandlerType: (*SearcherServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Search",
			Handler:       _Searcher_Search_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// NodeContentReaderClient is the client API for NodeContentReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeContentReaderClient interface {
}

type nodeContentReaderClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeContentReaderClient(cc grpc.ClientConnInterface) NodeContentReaderClient {
	return &nodeContentReaderClient{cc}
}

// NodeContentReaderServer is the server API for NodeContentReader service.
// All implementations must embed UnimplementedNodeContentReaderServer
// for forward compatibility
type NodeContentReaderServer interface {
	mustEmbedUnimplementedNodeContentReaderServer()
}

// UnimplementedNodeContentReaderServer must be embedded to have forward compatible implementations.
type UnimplementedNodeContentReaderServer struct {
}

func (UnimplementedNodeContentReaderServer) mustEmbedUnimplementedNodeContentReaderServer() {}

// UnsafeNodeContentReaderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeContentReaderServer will
// result in compilation errors.
type UnsafeNodeContentReaderServer interface {
	mustEmbedUnimplementedNodeContentReaderServer()
}

func RegisterNodeContentReaderServer(s grpc.ServiceRegistrar, srv NodeContentReaderServer) {
	s.RegisterService(&NodeContentReader_ServiceDesc, srv)
}

// NodeContentReader_ServiceDesc is the grpc.ServiceDesc for NodeContentReader service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeContentReader_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeContentReader",
	HandlerType: (*NodeContentReaderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "cells-tree.proto",
}

// NodeContentWriterClient is the client API for NodeContentWriter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeContentWriterClient interface {
}

type nodeContentWriterClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeContentWriterClient(cc grpc.ClientConnInterface) NodeContentWriterClient {
	return &nodeContentWriterClient{cc}
}

// NodeContentWriterServer is the server API for NodeContentWriter service.
// All implementations must embed UnimplementedNodeContentWriterServer
// for forward compatibility
type NodeContentWriterServer interface {
	mustEmbedUnimplementedNodeContentWriterServer()
}

// UnimplementedNodeContentWriterServer must be embedded to have forward compatible implementations.
type UnimplementedNodeContentWriterServer struct {
}

func (UnimplementedNodeContentWriterServer) mustEmbedUnimplementedNodeContentWriterServer() {}

// UnsafeNodeContentWriterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeContentWriterServer will
// result in compilation errors.
type UnsafeNodeContentWriterServer interface {
	mustEmbedUnimplementedNodeContentWriterServer()
}

func RegisterNodeContentWriterServer(s grpc.ServiceRegistrar, srv NodeContentWriterServer) {
	s.RegisterService(&NodeContentWriter_ServiceDesc, srv)
}

// NodeContentWriter_ServiceDesc is the grpc.ServiceDesc for NodeContentWriter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeContentWriter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeContentWriter",
	HandlerType: (*NodeContentWriterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "cells-tree.proto",
}

// NodeVersionerClient is the client API for NodeVersioner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeVersionerClient interface {
	CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...grpc.CallOption) (*CreateVersionResponse, error)
	StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...grpc.CallOption) (*StoreVersionResponse, error)
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (NodeVersioner_ListVersionsClient, error)
	HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...grpc.CallOption) (*HeadVersionResponse, error)
	PruneVersions(ctx context.Context, in *PruneVersionsRequest, opts ...grpc.CallOption) (*PruneVersionsResponse, error)
}

type nodeVersionerClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeVersionerClient(cc grpc.ClientConnInterface) NodeVersionerClient {
	return &nodeVersionerClient{cc}
}

func (c *nodeVersionerClient) CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...grpc.CallOption) (*CreateVersionResponse, error) {
	out := new(CreateVersionResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeVersioner/CreateVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...grpc.CallOption) (*StoreVersionResponse, error) {
	out := new(StoreVersionResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeVersioner/StoreVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (NodeVersioner_ListVersionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeVersioner_ServiceDesc.Streams[0], "/tree.NodeVersioner/ListVersions", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeVersionerListVersionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeVersioner_ListVersionsClient interface {
	Recv() (*ListVersionsResponse, error)
	grpc.ClientStream
}

type nodeVersionerListVersionsClient struct {
	grpc.ClientStream
}

func (x *nodeVersionerListVersionsClient) Recv() (*ListVersionsResponse, error) {
	m := new(ListVersionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeVersionerClient) HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...grpc.CallOption) (*HeadVersionResponse, error) {
	out := new(HeadVersionResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeVersioner/HeadVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) PruneVersions(ctx context.Context, in *PruneVersionsRequest, opts ...grpc.CallOption) (*PruneVersionsResponse, error) {
	out := new(PruneVersionsResponse)
	err := c.cc.Invoke(ctx, "/tree.NodeVersioner/PruneVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeVersionerServer is the server API for NodeVersioner service.
// All implementations must embed UnimplementedNodeVersionerServer
// for forward compatibility
type NodeVersionerServer interface {
	CreateVersion(context.Context, *CreateVersionRequest) (*CreateVersionResponse, error)
	StoreVersion(context.Context, *StoreVersionRequest) (*StoreVersionResponse, error)
	ListVersions(*ListVersionsRequest, NodeVersioner_ListVersionsServer) error
	HeadVersion(context.Context, *HeadVersionRequest) (*HeadVersionResponse, error)
	PruneVersions(context.Context, *PruneVersionsRequest) (*PruneVersionsResponse, error)
	mustEmbedUnimplementedNodeVersionerServer()
}

// UnimplementedNodeVersionerServer must be embedded to have forward compatible implementations.
type UnimplementedNodeVersionerServer struct {
}

func (UnimplementedNodeVersionerServer) CreateVersion(context.Context, *CreateVersionRequest) (*CreateVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVersion not implemented")
}
func (UnimplementedNodeVersionerServer) StoreVersion(context.Context, *StoreVersionRequest) (*StoreVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreVersion not implemented")
}
func (UnimplementedNodeVersionerServer) ListVersions(*ListVersionsRequest, NodeVersioner_ListVersionsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListVersions not implemented")
}
func (UnimplementedNodeVersionerServer) HeadVersion(context.Context, *HeadVersionRequest) (*HeadVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HeadVersion not implemented")
}
func (UnimplementedNodeVersionerServer) PruneVersions(context.Context, *PruneVersionsRequest) (*PruneVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PruneVersions not implemented")
}
func (UnimplementedNodeVersionerServer) mustEmbedUnimplementedNodeVersionerServer() {}

// UnsafeNodeVersionerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeVersionerServer will
// result in compilation errors.
type UnsafeNodeVersionerServer interface {
	mustEmbedUnimplementedNodeVersionerServer()
}

func RegisterNodeVersionerServer(s grpc.ServiceRegistrar, srv NodeVersionerServer) {
	s.RegisterService(&NodeVersioner_ServiceDesc, srv)
}

func _NodeVersioner_CreateVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeVersionerServer).CreateVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeVersioner/CreateVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeVersionerServer).CreateVersion(ctx, req.(*CreateVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeVersioner_StoreVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeVersionerServer).StoreVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeVersioner/StoreVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeVersionerServer).StoreVersion(ctx, req.(*StoreVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeVersioner_ListVersions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListVersionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeVersionerServer).ListVersions(m, &nodeVersionerListVersionsServer{stream})
}

type NodeVersioner_ListVersionsServer interface {
	Send(*ListVersionsResponse) error
	grpc.ServerStream
}

type nodeVersionerListVersionsServer struct {
	grpc.ServerStream
}

func (x *nodeVersionerListVersionsServer) Send(m *ListVersionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeVersioner_HeadVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeadVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeVersionerServer).HeadVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeVersioner/HeadVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeVersionerServer).HeadVersion(ctx, req.(*HeadVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeVersioner_PruneVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PruneVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeVersionerServer).PruneVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.NodeVersioner/PruneVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeVersionerServer).PruneVersions(ctx, req.(*PruneVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeVersioner_ServiceDesc is the grpc.ServiceDesc for NodeVersioner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeVersioner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.NodeVersioner",
	HandlerType: (*NodeVersionerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVersion",
			Handler:    _NodeVersioner_CreateVersion_Handler,
		},
		{
			MethodName: "StoreVersion",
			Handler:    _NodeVersioner_StoreVersion_Handler,
		},
		{
			MethodName: "HeadVersion",
			Handler:    _NodeVersioner_HeadVersion_Handler,
		},
		{
			MethodName: "PruneVersions",
			Handler:    _NodeVersioner_PruneVersions_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListVersions",
			Handler:       _NodeVersioner_ListVersions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}

// FileKeyManagerClient is the client API for FileKeyManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileKeyManagerClient interface {
	GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...grpc.CallOption) (*GetEncryptionKeyResponse, error)
}

type fileKeyManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewFileKeyManagerClient(cc grpc.ClientConnInterface) FileKeyManagerClient {
	return &fileKeyManagerClient{cc}
}

func (c *fileKeyManagerClient) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...grpc.CallOption) (*GetEncryptionKeyResponse, error) {
	out := new(GetEncryptionKeyResponse)
	err := c.cc.Invoke(ctx, "/tree.FileKeyManager/GetEncryptionKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileKeyManagerServer is the server API for FileKeyManager service.
// All implementations must embed UnimplementedFileKeyManagerServer
// for forward compatibility
type FileKeyManagerServer interface {
	GetEncryptionKey(context.Context, *GetEncryptionKeyRequest) (*GetEncryptionKeyResponse, error)
	mustEmbedUnimplementedFileKeyManagerServer()
}

// UnimplementedFileKeyManagerServer must be embedded to have forward compatible implementations.
type UnimplementedFileKeyManagerServer struct {
}

func (UnimplementedFileKeyManagerServer) GetEncryptionKey(context.Context, *GetEncryptionKeyRequest) (*GetEncryptionKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEncryptionKey not implemented")
}
func (UnimplementedFileKeyManagerServer) mustEmbedUnimplementedFileKeyManagerServer() {}

// UnsafeFileKeyManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileKeyManagerServer will
// result in compilation errors.
type UnsafeFileKeyManagerServer interface {
	mustEmbedUnimplementedFileKeyManagerServer()
}

func RegisterFileKeyManagerServer(s grpc.ServiceRegistrar, srv FileKeyManagerServer) {
	s.RegisterService(&FileKeyManager_ServiceDesc, srv)
}

func _FileKeyManager_GetEncryptionKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEncryptionKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileKeyManagerServer).GetEncryptionKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tree.FileKeyManager/GetEncryptionKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileKeyManagerServer).GetEncryptionKey(ctx, req.(*GetEncryptionKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileKeyManager_ServiceDesc is the grpc.ServiceDesc for FileKeyManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileKeyManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.FileKeyManager",
	HandlerType: (*FileKeyManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEncryptionKey",
			Handler:    _FileKeyManager_GetEncryptionKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-tree.proto",
}

// SyncChangesClient is the client API for SyncChanges service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SyncChangesClient interface {
	Put(ctx context.Context, opts ...grpc.CallOption) (SyncChanges_PutClient, error)
	Search(ctx context.Context, in *SearchSyncChangeRequest, opts ...grpc.CallOption) (SyncChanges_SearchClient, error)
}

type syncChangesClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncChangesClient(cc grpc.ClientConnInterface) SyncChangesClient {
	return &syncChangesClient{cc}
}

func (c *syncChangesClient) Put(ctx context.Context, opts ...grpc.CallOption) (SyncChanges_PutClient, error) {
	stream, err := c.cc.NewStream(ctx, &SyncChanges_ServiceDesc.Streams[0], "/tree.SyncChanges/Put", opts...)
	if err != nil {
		return nil, err
	}
	x := &syncChangesPutClient{stream}
	return x, nil
}

type SyncChanges_PutClient interface {
	Send(*SyncChange) error
	CloseAndRecv() (*PutSyncChangeResponse, error)
	grpc.ClientStream
}

type syncChangesPutClient struct {
	grpc.ClientStream
}

func (x *syncChangesPutClient) Send(m *SyncChange) error {
	return x.ClientStream.SendMsg(m)
}

func (x *syncChangesPutClient) CloseAndRecv() (*PutSyncChangeResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PutSyncChangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *syncChangesClient) Search(ctx context.Context, in *SearchSyncChangeRequest, opts ...grpc.CallOption) (SyncChanges_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &SyncChanges_ServiceDesc.Streams[1], "/tree.SyncChanges/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &syncChangesSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SyncChanges_SearchClient interface {
	Recv() (*SyncChange, error)
	grpc.ClientStream
}

type syncChangesSearchClient struct {
	grpc.ClientStream
}

func (x *syncChangesSearchClient) Recv() (*SyncChange, error) {
	m := new(SyncChange)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SyncChangesServer is the server API for SyncChanges service.
// All implementations must embed UnimplementedSyncChangesServer
// for forward compatibility
type SyncChangesServer interface {
	Put(SyncChanges_PutServer) error
	Search(*SearchSyncChangeRequest, SyncChanges_SearchServer) error
	mustEmbedUnimplementedSyncChangesServer()
}

// UnimplementedSyncChangesServer must be embedded to have forward compatible implementations.
type UnimplementedSyncChangesServer struct {
}

func (UnimplementedSyncChangesServer) Put(SyncChanges_PutServer) error {
	return status.Errorf(codes.Unimplemented, "method Put not implemented")
}
func (UnimplementedSyncChangesServer) Search(*SearchSyncChangeRequest, SyncChanges_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSyncChangesServer) mustEmbedUnimplementedSyncChangesServer() {}

// UnsafeSyncChangesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncChangesServer will
// result in compilation errors.
type UnsafeSyncChangesServer interface {
	mustEmbedUnimplementedSyncChangesServer()
}

func RegisterSyncChangesServer(s grpc.ServiceRegistrar, srv SyncChangesServer) {
	s.RegisterService(&SyncChanges_ServiceDesc, srv)
}

func _SyncChanges_Put_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SyncChangesServer).Put(&syncChangesPutServer{stream})
}

type SyncChanges_PutServer interface {
	SendAndClose(*PutSyncChangeResponse) error
	Recv() (*SyncChange, error)
	grpc.ServerStream
}

type syncChangesPutServer struct {
	grpc.ServerStream
}

func (x *syncChangesPutServer) SendAndClose(m *PutSyncChangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *syncChangesPutServer) Recv() (*SyncChange, error) {
	m := new(SyncChange)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SyncChanges_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchSyncChangeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SyncChangesServer).Search(m, &syncChangesSearchServer{stream})
}

type SyncChanges_SearchServer interface {
	Send(*SyncChange) error
	grpc.ServerStream
}

type syncChangesSearchServer struct {
	grpc.ServerStream
}

func (x *syncChangesSearchServer) Send(m *SyncChange) error {
	return x.ServerStream.SendMsg(m)
}

// SyncChanges_ServiceDesc is the grpc.ServiceDesc for SyncChanges service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SyncChanges_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tree.SyncChanges",
	HandlerType: (*SyncChangesServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Put",
			Handler:       _SyncChanges_Put_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Search",
			Handler:       _SyncChanges_Search_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "cells-tree.proto",
}
