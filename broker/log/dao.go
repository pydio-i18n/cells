/*
 * Copyright (c) 2024. Abstrium SAS <team (at) pydio.com>
 * This file is part of Pydio Cells.
 *
 * Pydio Cells is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Pydio Cells is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Pydio Cells.  If not, see <http://www.gnu.org/licenses/>.
 *
 * The latest code can be found at <https://pydio.com>.
 */

// Package log provides a persistence layer for json-formatted logs generated by the application.
//
// It is intended to provide an out-of-the-box solution for storing and querying the logs, but should be
// replaced by more scalable solutions like ELK.
package log

import (
	"context"
	"time"

	"github.com/pydio/cells/v4/common/proto/log"
	"github.com/pydio/cells/v4/common/runtime/manager"
	"github.com/pydio/cells/v4/common/service"
	"github.com/pydio/cells/v4/common/storage/indexer"
	log2 "github.com/pydio/cells/v4/common/telemetry/log"
	json "github.com/pydio/cells/v4/common/utils/jsonx"
)

var Drivers = service.StorageDrivers{}

// MessageRepository exposes interface methods to manage the log messages provided by Pydio.
type MessageRepository interface {
	PutLog(context.Context, *log.Log) error
	ListLogs(context.Context, string, int32, int32) (chan log.ListLogResponse, error)
	DeleteLogs(context.Context, string) (int64, error)
	AggregatedLogs(context.Context, string, string, int32) (chan log.TimeRangeResponse, error)
	Close(context.Context) error
	Resync(context.Context, log2.ZapLogger) error
	Truncate(context.Context, int64, log2.ZapLogger) error
	NewBatch(ctx context.Context, options ...indexer.BatchOption) (indexer.Batch, error)
}

func Migrate(mainCtx, fromCtx, toCtx context.Context, dryRun bool, status chan service.MigratorStatus) (map[string]int, error) {
	out := map[string]int{
		"Message": 0,
	}
	from, er := manager.Resolve[MessageRepository](fromCtx)
	if er != nil {
		return nil, er
	}
	to, er := manager.Resolve[MessageRepository](toCtx)
	if er != nil {
		return nil, er
	}

	bg := mainCtx

	pageSize := int32(1000)
	offset := int32(0)
	for {
		ll, er := from.ListLogs(bg, "", offset, pageSize)
		if er != nil {
			return out, er
		}
		hasResult := false
		for lResp := range ll {
			hasResult = true
			out["Message"]++
			if !dryRun {
				mess := lResp.LogMessage
				var marshed map[string]interface{}
				data, _ := json.Marshal(mess)
				_ = json.Unmarshal(data, &marshed) // Reformat some keys
				marshed["level"] = mess.Level
				delete(marshed, "Level")
				marshed["logger"] = mess.Logger
				delete(marshed, "Logger")
				marshed["ts"] = time.Unix(int64(mess.Ts), 0).Format(time.RFC3339)
				delete(marshed, "Ts")
				marshed["msg"] = mess.Msg
				delete(marshed, "Msg")
				if mess.JsonZaps != "" {
					var zaps map[string]interface{}
					_ = json.Unmarshal([]byte(mess.JsonZaps), &zaps)
					for k, v := range zaps {
						marshed[k] = v
					}
					delete(marshed, "JsonZaps")
				}
				data, _ = json.Marshal(marshed)
				if er := to.PutLog(bg, &log.Log{
					Nano:    mess.GetTs() * 1000,
					Message: data,
				}); er != nil {
					return out, er
				}
			}
		}
		if hasResult {
			offset++
		} else {
			break
		}
	}
	<-time.After(4 * time.Second)

	return out, nil
}
