package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"strings"

	setter "github.com/pydio/cells/common/proto/options/setter"
)

const (
	fmtPackage             = protogen.GoImportPath("fmt")
	contextPackage         = protogen.GoImportPath("context")
	syncPackage            = protogen.GoImportPath("sync")
	grpcPackage            = protogen.GoImportPath("google.golang.org/grpc")
	statusPackage          = protogen.GoImportPath("google.golang.org/grpc/status")
	codesPackage           = protogen.GoImportPath("google.golang.org/grpc/codes")
	metadataContextPackage = protogen.GoImportPath("google.golang.org/grpc/metadata")
)

// generateFile generates a _grpc.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_grpc.setter.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-grpc. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-go-grpc v", version)
	g.P("// - protoc             ", protocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	generateFileContent(gen, file, g)
	return g
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// generateFileContent generates the gRPC service definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Services) == 0 {
		return
	}

	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the grpc package it is being compiled against.")
	g.P("// Requires gRPC-Go v1.32.0 or later.")
	g.P("const _ = ", grpcPackage.Ident("SupportPackageIsVersion7")) // When changing, update version number above.
	g.P()

	for _, message := range file.Messages {
		allMessages, ok := proto.GetExtension(file.Desc.Options(), setter.E_AllMessages).(bool)
		if !ok {
			return
		}

		type function struct {
			name   string
			typeof string
		}

		var getters []function
		var setters []function
		interfaces := []string{}

		// Add Getter Interface
		for _, field := range message.Fields {
			allFields, ok := proto.GetExtension(message.Desc.Options(), setter.E_AllFields).(bool)
			if !ok {
				return
			}

			if !allMessages {
				if !allFields {
					if !allFields {
						include, ok := proto.GetExtension(field.Desc.Options(), setter.E_Include).(bool)
						if !ok {
							continue
						}

						if !include {
							continue
						}
					} else {
						exclude, ok := proto.GetExtension(field.Desc.Options(), setter.E_Exclude).(bool)
						if !ok {
							continue
						}

						if exclude {
							continue
						}
					}
				}
			}

			// Checking if the field refers to a message that is also a getter / setter
			// In which case we would create a generic interface for the current message
			doIt := false
			if targetMsg := field.Desc.Message(); targetMsg != nil {

				targetMsgAllMessages, ok := proto.GetExtension(targetMsg.ParentFile().Options(), setter.E_AllMessages).(bool)
				if ok {
					if !targetMsgAllMessages {
						allFields, ok := proto.GetExtension(targetMsg.Options(), setter.E_AllFields).(bool)
						if !ok {
							return
						}

						if allFields {
							doIt = true
						}
					} else {
						doIt = true
					}
				}
			}

			if doIt {
				targetName := "I" + field.Desc.TextName()
				t := ""
				found := false
				for k, i := range interfaces {
					if i == targetName {
						t = fmt.Sprintf("T%d", k)
						found = true
						break
					}
				}
				if !found {
					interfaces = append(interfaces, targetName)
					t = fmt.Sprintf("T%d", len(interfaces)-1)
				}
				getters = append(getters, function{
					name:   field.GoName,
					typeof: t,
				})
			} else {
				t, _ := fieldGoType(g, field)
				getters = append(getters, function{
					name:   field.GoName,
					typeof: t,
				})
			}
		}

		// Add Setter Interface
		for _, field := range message.Fields {
			allFields, ok := proto.GetExtension(message.Desc.Options(), setter.E_AllFields).(bool)
			if !ok {
				return
			}

			if !allMessages {
				if !allFields {
					if !allFields {
						include, ok := proto.GetExtension(field.Desc.Options(), setter.E_Include).(bool)
						if !ok {
							continue
						}

						if !include {
							continue
						}
					} else {
						exclude, ok := proto.GetExtension(field.Desc.Options(), setter.E_Exclude).(bool)
						if !ok {
							continue
						}

						if exclude {
							continue
						}
					}
				}
			}

			// Checking if the field refers to a message that is also a getter / setter
			// In which case we would create a generic interface for the current message
			doIt := false
			if targetMsg := field.Desc.Message(); targetMsg != nil {

				targetMsgAllMessages, ok := proto.GetExtension(targetMsg.ParentFile().Options(), setter.E_AllMessages).(bool)
				if ok {
					if !targetMsgAllMessages {
						allFields, ok := proto.GetExtension(targetMsg.Options(), setter.E_AllFields).(bool)
						if !ok {
							return
						}

						if allFields {
							doIt = true
						}
					} else {
						doIt = true
					}
				}
			}

			if doIt {
				targetName := "I" + field.Desc.TextName()
				t := ""
				found := false
				for k, i := range interfaces {
					if i == targetName {
						t = fmt.Sprintf("T%d", k)
						found = true
						break
					}
				}
				if !found {
					interfaces = append(interfaces, targetName)
					t = fmt.Sprintf("T%d", len(interfaces)-1)
				}
				setters = append(setters, function{
					name:   field.GoName,
					typeof: t,
				})
			} else {
				t, _ := fieldGoType(g, field)
				setters = append(setters, function{
					name:   field.GoName,
					typeof: t,
				})
			}
		}

		var interfaceStr []string
		if len(interfaces) > 0 {
			for k, i := range interfaces {
				interfaceStr = append(interfaceStr, fmt.Sprintf("T%d %s", k, i))
			}
		}

		if len(getters) > 0 {
			iName := "Getter"
			if len(interfaceStr) > 0 {
				iName += "[" + strings.Join(interfaceStr, ", ") + "]"
			}
			g.P("type ", message.GoIdent.GoName, iName, " interface {")
			for _, getter := range getters {
				g.P("Get", getter.name, "() ", getter.typeof)
			}
			g.P("}")
		}

		if len(setters) > 0 {
			iName := "Setter"
			if len(interfaceStr) > 0 {
				iName += "[" + strings.Join(interfaceStr, ", ") + "]"
			}
			g.P("type ", message.GoIdent.GoName, iName, " interface {")
			for _, setter := range setters {
				g.P("Set", setter.name, "(", setter.typeof, ")")
			}
			g.P("}")
		}

		if len(getters) > 0 || len(setters) > 0 {
			iName := ""
			if len(interfaceStr) > 0 {
				iName += "[" + strings.Join(interfaceStr, ", ") + "]"
			}

			g.P("type I", message.GoIdent.GoName, iName, " interface {")

			var gName []string
			gNameStr := ""
			if len(interfaceStr) > 0 {
				for k := range interfaceStr {
					gName = append(gName, fmt.Sprintf("T%d", k))

				}

				gNameStr = "[" + strings.Join(gName, ", ") + "]"
			}

			var rName []string
			rNameStr := ""
			if len(interfaces) > 0 {
				for _, i := range interfaces {
					rName = append(rName, i)
				}

				rNameStr = "[" + strings.Join(rName, ", ") + "]"
			}

			if len(getters) > 0 {
				g.P(message.GoIdent.GoName, "Getter", gNameStr)
			}
			if len(setters) > 0 {
				g.P(message.GoIdent.GoName, "Setter", gNameStr)
			}
			g.P("}")

			if len(rName) > 0 {
				g.P("type II", message.GoIdent.GoName, " I", message.GoIdent.GoName, rNameStr)
			}
		}

		genMessage(gen, file, g, message)
	}
}

func genMessage(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, message *protogen.Message) {
	allMessages, ok := proto.GetExtension(file.Desc.Options(), setter.E_AllMessages).(bool)
	if !ok {
		return
	}

	allFields, ok := proto.GetExtension(message.Desc.Options(), setter.E_AllFields).(bool)
	if !ok {
		return
	}

	for _, field := range message.Fields {
		if !allMessages {
			if !allFields {
				include, ok := proto.GetExtension(field.Desc.Options(), setter.E_Include).(bool)
				if !ok {
					continue
				}

				if !include {
					continue
				}
			} else {
				exclude, ok := proto.GetExtension(field.Desc.Options(), setter.E_Exclude).(bool)
				if !ok {
					continue
				}

				if exclude {
					continue
				}
			}
		}

		genField(gen, file, g, field)
	}
}

func genField(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, field *protogen.Field) {
	t, _ := fieldGoType(g, field)
	g.P("func (x *", field.Parent.GoIdent.GoName, ") Set", field.GoName, "(v ", t, ") {")
	g.P("x.", field.GoName, " = v")
	g.P("}")
}

// fieldGoType returns the Go type used for a field.
//
// If it returns pointer=true, the struct field is a pointer to the type.
func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.MessageKind, protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}
