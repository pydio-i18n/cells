// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package user_model

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newUser(db *gorm.DB, opts ...gen.DOOption) user {
	_user := user{}

	_user.userDo.UseDB(db, opts...)
	_user.userDo.UseModel(&User{})

	tableName := _user.userDo.TableName()
	_user.ALL = field.NewAsterisk(tableName)
	_user.Uuid = field.NewString(tableName, "uuid")
	_user.Type = field.NewInt32(tableName, "leaf")
	_user.Size = field.NewInt64(tableName, "size")
	_user.MTime = field.NewInt64(tableName, "mtime")
	_user.Mode = field.NewInt32(tableName, "mode")
	_user.Etag = field.NewString(tableName, "etag")
	_user.Name = field.NewString(tableName, "name")
	_user.Level = field.NewInt(tableName, "level")
	_user.Mpath1 = field.NewString(tableName, "mpath1")
	_user.Mpath2 = field.NewString(tableName, "mpath2")
	_user.Mpath3 = field.NewString(tableName, "mpath3")
	_user.Mpath4 = field.NewString(tableName, "mpath4")
	_user.Hash = field.NewString(tableName, "hash")
	_user.Hash2 = field.NewString(tableName, "hash2")

	_user.fillFieldMap()

	return _user
}

type user struct {
	userDo userDo

	ALL    field.Asterisk
	Uuid   field.String
	Type   field.Int32
	Size   field.Int64
	MTime  field.Int64
	Mode   field.Int32
	Etag   field.String
	Name   field.String
	Level  field.Int
	Mpath1 field.String
	Mpath2 field.String
	Mpath3 field.String
	Mpath4 field.String
	Hash   field.String
	Hash2  field.String

	fieldMap map[string]field.Expr
}

func (u user) Table(newTableName string) *user {
	u.userDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u user) As(alias string) *user {
	u.userDo.DO = *(u.userDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *user) updateTableName(table string) *user {
	u.ALL = field.NewAsterisk(table)
	u.Uuid = field.NewString(table, "uuid")
	u.Type = field.NewInt32(table, "leaf")
	u.Size = field.NewInt64(table, "size")
	u.MTime = field.NewInt64(table, "mtime")
	u.Mode = field.NewInt32(table, "mode")
	u.Etag = field.NewString(table, "etag")
	u.Name = field.NewString(table, "name")
	u.Level = field.NewInt(table, "level")
	u.Mpath1 = field.NewString(table, "mpath1")
	u.Mpath2 = field.NewString(table, "mpath2")
	u.Mpath3 = field.NewString(table, "mpath3")
	u.Mpath4 = field.NewString(table, "mpath4")
	u.Hash = field.NewString(table, "hash")
	u.Hash2 = field.NewString(table, "hash2")

	u.fillFieldMap()

	return u
}

func (u *user) WithContext(ctx context.Context) *userDo { return u.userDo.WithContext(ctx) }

func (u user) TableName() string { return u.userDo.TableName() }

func (u user) Alias() string { return u.userDo.Alias() }

func (u user) Columns(cols ...field.Expr) gen.Columns { return u.userDo.Columns(cols...) }

func (u *user) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *user) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 14)
	u.fieldMap["uuid"] = u.Uuid
	u.fieldMap["leaf"] = u.Type
	u.fieldMap["size"] = u.Size
	u.fieldMap["mtime"] = u.MTime
	u.fieldMap["mode"] = u.Mode
	u.fieldMap["etag"] = u.Etag
	u.fieldMap["name"] = u.Name
	u.fieldMap["level"] = u.Level
	u.fieldMap["mpath1"] = u.Mpath1
	u.fieldMap["mpath2"] = u.Mpath2
	u.fieldMap["mpath3"] = u.Mpath3
	u.fieldMap["mpath4"] = u.Mpath4
	u.fieldMap["hash"] = u.Hash
	u.fieldMap["hash2"] = u.Hash2
}

func (u user) clone(db *gorm.DB) user {
	u.userDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u user) replaceDB(db *gorm.DB) user {
	u.userDo.ReplaceDB(db)
	return u
}

type userDo struct{ gen.DO }

// FilterWithLowerVal is a code snippet to filter a column using its lower value
//
// where lower(@@column) = lower(@value) (gen.M, error)
func (u userDo) FilterWithLowerVal(column string, value string) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, value)
	generateSQL.WriteString("where lower(" + u.Quote(column) + ") = lower(?) (gen.M, error) ")

	var executeSQL *gorm.DB
	executeSQL = u.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	_ = executeSQL

	return
}

func (u userDo) Debug() *userDo {
	return u.withDO(u.DO.Debug())
}

func (u userDo) WithContext(ctx context.Context) *userDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userDo) ReadDB() *userDo {
	return u.Clauses(dbresolver.Read)
}

func (u userDo) WriteDB() *userDo {
	return u.Clauses(dbresolver.Write)
}

func (u userDo) Session(config *gorm.Session) *userDo {
	return u.withDO(u.DO.Session(config))
}

func (u userDo) Clauses(conds ...clause.Expression) *userDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userDo) Returning(value interface{}, columns ...string) *userDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userDo) Not(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userDo) Or(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userDo) Select(conds ...field.Expr) *userDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userDo) Where(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userDo) Order(conds ...field.Expr) *userDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userDo) Distinct(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userDo) Omit(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userDo) Join(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userDo) Group(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userDo) Having(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userDo) Limit(limit int) *userDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userDo) Offset(offset int) *userDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *userDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userDo) Unscoped() *userDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userDo) Create(values ...*User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userDo) CreateInBatches(values []*User, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userDo) Save(values ...*User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userDo) First() (*User, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*User), nil
	}
}

func (u userDo) Take() (*User, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*User), nil
	}
}

func (u userDo) Last() (*User, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*User), nil
	}
}

func (u userDo) Find() ([]*User, error) {
	result, err := u.DO.Find()
	return result.([]*User), err
}

func (u userDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*User, err error) {
	buf := make([]*User, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userDo) FindInBatches(result *[]*User, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userDo) Attrs(attrs ...field.AssignExpr) *userDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userDo) Assign(attrs ...field.AssignExpr) *userDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userDo) Joins(fields ...field.RelationField) *userDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userDo) Preload(fields ...field.RelationField) *userDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userDo) FirstOrInit() (*User, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*User), nil
	}
}

func (u userDo) FirstOrCreate() (*User, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*User), nil
	}
}

func (u userDo) FindByPage(offset int, limit int) (result []*User, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userDo) Delete(models ...*User) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userDo) withDO(do gen.Dao) *userDo {
	u.DO = *do.(*gen.DO)
	return u
}
